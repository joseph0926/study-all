---
name: project-learn
description: 프로젝트 코드베이스 자유 Q&A — 질문 → 근거 탐색(소스/문서/git/웹/추론) → 답변 → 반복 → 문서화. Codex에서는 `$project-learn <path> <질문>`으로 호출한다.
---

# project-learn

입력: `$project-learn <project-path> <질문>` (예: `$project-learn /path/to/project 인증 흐름이 어떻게 구현되어있나요?`)

실행 순서:

1. `$ARGUMENTS`에서 `<project-path>` + `<질문>` 파싱
2. `mcp__study__context_resolve(mode=project, projectPath=<project-path>)` 호출
3. 사용자 질문에서 주제명 추출 (간결한 kebab-case, 예: `인증-흐름`)
4. 세션 복원/초기화

   상태 파일: `{project}/.study/learn/session-state.md`

   4-A. Read 시도:
     - 파일 없음 또는 `# COMPLETED` → 새 세션 → Step 4-C
     - 활성 내용 + 당일 → "이전 세션 복원. Q{N}부터 계속합니다." → 상태 복원 → Step 5
     - 활성 내용 + 이전 날짜 → "이전 세션 발견 ({날짜}). 이어서/새로?" → 사용자 선택

   4-B. 복원 정보:
     - topic, qaCount, frameType, connections, nextDirection, qaHistory

   4-C. 새 세션 → 상태 파일 초기화 Write:
     ```
     # SESSION-STATE
     updated: {YYYY-MM-DD HH:MM}
     topic: {주제명}
     qaCount: 0
     frameType: (미결정)
     connections: (없음)
     nextDirection: 초기 탐색
     ---
     ## QA History
     (없음)
     ```

5. 탐색 범위 설정

   프로젝트 규모별 전략:
   - **소규모** (<100 파일): 전체 탐색
   - **중규모** (100~500): 진입점 기반 (package.json → 키워드 Grep → import 체인 1~2단계)
   - **대규모** (500+): 점진적 심화 (디렉토리 단위 식별 → 범위 확인 후 상세)

   파일 수 확인: `Glob("**/*")` 또는 프로젝트 구조 탐색으로 규모를 판단한다.

6. 근거 탐색 — 아래 우선순위를 순서대로 시도한다.

   | 우선순위 | 소스 | 도구 | 조건 |
   |---------|------|------|------|
   | 1 | 프로젝트 소스코드 | Glob, Grep, Read | `file:line` 인용 필수 |
   | 2 | 프로젝트 문서 (README, ADR, docs/ 등) | Glob, Read | 존재 시 |
   | 3 | ref/ 교차참조 | Glob, Grep, Read | 프로젝트 import 대상 라이브러리의 소스가 ref/에 존재할 때 |
   | 4 | git history (blame, log) | git blame, git log | **판단 가능한 경우만** (아래 규칙 참조) |
   | 5 | 웹 검색 | WebSearch, WebFetch | 외부 패턴/라이브러리 이해 필요 시 |
   | 6 | 추론 | — | 1~5 결과를 바탕으로 추론. 반드시 "추론:" 접두사 명시 |

   git history 사용 규칙:
   - conventional commit / 명확한 PR 설명 → 근거로 인용
   - "fix bug", "update" 등 불명확한 메시지 → 건너뜀, 언급하지 않음
   - blame으로 작성 시점만 유용한 경우 → "시점:" 접두사로 제한적 인용
   - 불명확한 git history를 근거로 사용하지 않는다

   ref/ 교차참조 규칙:
   - 프로젝트 소스에서 외부 라이브러리 import 발견 → `ref/` Glob 확인
   - 존재 → "ref 소스:" 접두사로 내부 동작 인용
   - 용도: 프로젝트 사용부(project)와 라이브러리 구현부(ref/) 교차 설명
   - ref/에 없으면 → 건너뛰기

7. 아래 순서로 답변한다. (프레임 → 상세 → 통합)
   - 7-A. **패턴 매핑** — 해당 코드가 사용하는 디자인 패턴이나 아키텍처 패턴을 **먼저** 식별한다.
     - 목적: 세부 코드 설명 전에 전체 구조 프레임을 형성한다.
     - 알려진 패턴에 매핑하고, 매핑 근거를 명시한다.
       (예: "Strategy 패턴 — 결제 수단별 처리를 분리하고 있다. `PaymentProcessor` 인터페이스가 Strategy에 해당")
     - 매핑 가능한 패턴이 없으면 "커스텀 구조:" 접두사로 구조 요약만 제시한다.
     - "커스텀 구조:" 시 비유를 병행한다: 실생활 1:1 대응 비유로 구조를 설명한다 (대응 요소 3개 이상).
     - 비유 불가 시 → "비유 한계:" 접두사로 이유와 부분 비유를 제시한다.
     - 알려진 패턴이라도 생소한 경우(Visitor, Mediator 등) → 선택적으로 비유를 추가한다.
     - 패턴명만으로 명확한 경우(Singleton, Observer 등) → 비유 불필요.
     - 억지 매핑/억지 비유 금지. 패턴명을 붙이기 애매하면 "커스텀 구조:"가 낫다.
   - 7-B. **코드 추적** — 패턴 프레임 위에 코드 근거를 쌓는다.
     - 프로젝트 소스 근거: `file:line` 경로 포함
     - 프로젝트 문서 근거: 문서 경로 포함
     - ref/ 소스 근거: "ref 소스:" 접두사 + `ref/<lib>/path:line`
     - 교차 인용: 프로젝트 사용부(`project:N`)와 라이브러리 구현부(`ref/:M`) 병렬 인용
     - git 근거: 커밋 해시 + 메시지 포함 (판단 가능한 경우만)
     - 웹 근거: 출처 URL 포함
     - 추론: "추론:" 접두사로 명확히 구분
     - 코드 설명 시 패턴 요소와의 매칭 이유를 서술한다.
       (예: "패턴에서 Context에 해당하는 것이 코드에서는 PaymentService인데, 그 이유는 …")
   - 7-C. **시각화** — 최종 정리로 핵심을 시각화한다.
     - 호출 그래프, 의존성 다이어그램, 데이터 흐름도, 컴포넌트 트리 중 적합한 것을 선택한다.
     - 패턴 요소 ↔ 실제 코드 매핑을 시각화에 반영하면 더 좋다.
     - 생략 조건: 단일 사실 확인(예/아니오 수준)인 경우.
     - 거창할 필요 없다. 핵심 관계나 흐름만 보여준다.
   - 7-D. **이중 연결** — 프로젝트 내부 + 학습 토픽 연관을 탐색한다.
     - **프로젝트 내부 연결**: 관련 모듈/파일 간 의존 관계를 Grep/Glob으로 추적한다.
       (예: "이 인증 모듈은 `middleware/auth.ts`와 `api/session.ts`에서 사용됨")
     - **학습 토픽 연결**: `study/` 디렉토리를 Glob/Grep/Read로 스캔한다.
       (예: "이 구현은 `study/react/Suspense-동작원리.md`에서 학습한 Promise catch 메커니즘 활용")
     - 대화 중: 발견 시 간략히 언급한다.
     - 문서: `## 연결` 섹션에 구조적으로 기록한다.
     - 판단 기준: 동일 개념의 다른 관점, 상위/하위 메커니즘, 인과 관계, 전제 지식.
     - 억지 연결 금지 (단순 동일 라이브러리 수준은 연결하지 않는다).
8. 사용자의 추가 질문을 대기한다. → Step 6~7 반복.
   - 매 Q&A 후 `{project}/.study/learn/session-state.md`를 Write 갱신한다 (qaCount++, frameType, connections, nextDirection, QA History 추가).

종료(`>>정리`) 시:

1. 전체 Q&A를 `{project}/.study/learn/<주제명>.md`에 Write한다.
   - 포맷: 아래 템플릿을 따른다.
   - 원문 그대로 기록한다. 오탈자만 수정.
2. `mcp__study__session_appendLog(context, topic=<주제명>, content=<요약>, via="via /project-learn")`로 세션 기록.
3. `{project}/.study/learn/session-state.md`를 `# COMPLETED\n` 마커로 Write한다.

문서 템플릿:

```markdown
# <주제명>

> 최초 질문: <사용자의 원본 질문>
> 프로젝트: <project-path>
> 일시: <YYYY-MM-DD>

---

## Q1. <사용자 질문>

<답변 원문>

## Q2. <사용자 후속 질문>

<답변 원문>

...

---

## 연결

### 프로젝트 내부

| 모듈/파일 | 관계 | 근거 |
|-----------|------|------|
| `src/...` | <관계 유형> | <왜 연결되는지> |

### 학습 토픽

| 대상 토픽 | 관계 | 근거 |
|-----------|------|------|
| `study/<skill>/<Topic>.md` | <관계 유형> | <왜 연결되는지> |

연결이 없으면 해당 하위 섹션을 생략한다.
```

사용자 신호 규칙:
- `>>정리` — 세션 종료 + 문서화 실행
- 일반 대화 속 "정리"는 신호로 인식하지 않는다 (`>>` 접두사 필수).

규칙:
- 프로젝트 소스코드를 반드시 먼저 탐색한다. 웹 검색만으로 대체하지 않는다.
- 근거의 출처(소스코드/문서/git/웹/추론)를 항상 명시한다.
- 쓰기 동작은 `>>정리` 이후에만 수행한다. 예외: `session-state.md`는 매 Q&A 후 갱신한다.
- 답변 순서: 패턴 매핑(프레임) → 코드 추적(근거+매칭) → 시각화(통합 정리) → 이중 연결. 이 순서를 지킨다.
- 패턴 매핑은 알려진 패턴에 대응 가능할 때만. 억지 매핑보다 "커스텀 구조:" 설명이 낫다.
- "커스텀 구조:" 시 비유 병행 (1:1 대응, 요소 3개 이상). 억지 비유보다 "비유 한계:" 설명이 낫다.
- ref/ 교차참조: 프로젝트 import 대상 라이브러리가 ref/에 존재할 때만 인용한다. 무관한 ref/ 인용 금지.
- 코드 추적 시 패턴 요소와의 매칭 이유를 반드시 서술한다.
- 시각화는 단일 사실 확인이 아닌 한 포함한다. 최종 정리 역할.
- 이중 연결에서 프로젝트 내부와 학습 토픽 모두 탐색한다. 억지 연결 금지.
- 프로젝트 코드를 수정하지 않는다 (읽기 전용).
- git history는 판단 가능한 경우에만 근거로 사용한다. 불명확한 커밋 메시지를 근거로 삼지 않는다.
