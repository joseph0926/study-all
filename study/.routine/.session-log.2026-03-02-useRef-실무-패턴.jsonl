{"phase":0,"type":"init","topic":"useRef 실무 패턴","refDirs":["ref/react/"],"ts":"2026-03-02T02:05:34.689Z"}
{"phase":1,"type":"qa","userQuestion":"그러면 최초 useDebouncedCallback(() => console.log(\"test\"), 100, inputs왜 필요하지..?) 호출시에는\n1. const timeoutID = useRef(-1); 라인 실행 -> timeoutID = {current: -1}\n2. clearTimeout(timeoutID.current); 라인 실행 -> 이때 timeoutID는 timeout 타입이 아니지 않나?\n3. timeoutID.current = setTimeout(callback, ms, ...args); 라인 실행 -> 이때야 timeoutID에 timeout 타입이 할당?","aiAnswer":"clearTimeout의 HTML 스펙(WHATWG)에 의해 매핑 없는 ID는 무시됨. clearTimeout(-1)은 안전. 초기값 -1은 센티넬 값 패턴 — setTimeout은 양수만 반환하므로 유효한 ID와 충돌 불가, 타입도 number로 일관. null 대신 -1을 쓰면 타입 좁히기(null check) 불필요.","refs":["ref/react/packages/react-reconciler/src/__tests__/useRef-test.internal.js:48-105"],"links":[],"ts":"2026-03-02T02:15:24.084Z"}
{"phase":1,"type":"qa","userQuestion":"1. fragmentRef.current.observeUsing(resizeObserver); 이때 fragmentRef.current는 null 아닌가요?\n2. 왜 위험한지 잘 이해가 안가는데요, 그냥 fragmentRef.current을 클린업하면 fragmentRef.current가 최초에는 <div> DOM의 ref였고, 그걸 클린업할걸 기대했지만, 중간에 <li>로 바뀌어도 React는 모른다 << 이게 맞나요?\n(추가) A,B 모두 useEffect에서 딱히 DOM을 연결하는 코드가 없는거 아닌가요?","aiAnswer":"Q1: useEffect는 커밋 완료 후 실행됨. 커밋 순서: commitMutationEffects(DOM 변경) → commitLayoutEffects(ref.current = DOM) → commitPassiveMountEffects(useEffect 실행). 그래서 useEffect 안에서 ref.current는 이미 DOM을 가리킴.\n\nQ2: React가 모르는 게 아니라, cleanup 실행 시점에 ref.current가 이미 새 DOM으로 갱신되어 있기 때문. cleanup 클로저가 만들어진 시점과 실행 시점 사이에 ref.current가 바뀔 수 있음. 캡처(const last = ref.current)로 고정해야 안전.\n\n추가: ref와 DOM 연결은 JSX의 ref={fragmentRef} 속성으로 커밋 단계에서 React가 자동 처리. useEffect 안의 코드는 이미 연결된 DOM에 Observer를 등록하는 것.","refs":["ref/react/fixtures/dom/src/components/fixtures/fragment-refs/ResizeObserverCase.js:7-30","ref/react/fixtures/dom/src/components/fixtures/fragment-refs/IntersectionObserverCase.js:25-58","ref/react/packages/react-reconciler/src/ReactFiberCommitWork.js"],"links":[],"ts":"2026-03-02T02:23:07.877Z"}
{"phase":1,"type":"qa","userQuestion":"패턴 3은 그러면 아래 흐름인가요?\nconst Test = () => {\n  const [num, setNum] = useState(5)\n  const prevValue = usePrevious(num);\n  // 1. 초기에 return ref.current이므로 null 반환됨\n  // 2. 렌더 후 useEffect로 인해 ref.current에 5가 저장됨\n  // 3. Test 컴포넌트 리렌더시 prevValue는 return ref.current로 5 반환\n};\n\n패턴 4는 패턴 3과 비슷해보이는데 최신값 반환하는 이유는 return시 함수 호출이라 그런건가요?","aiAnswer":"패턴 3 흐름 정확. 단, 초기값은 null이 아니라 undefined (useRef()에 인자 없으면 {current: undefined}).\n\n패턴 4는 맞음. 핵심은 \"반환 시점\"의 차이:\n- 패턴 3: return ref.current → 렌더 시점에 ref 값 읽기 → 이전 값\n- 패턴 4: return 함수 께데기 → 렌더 시점에는 ref 안 읽음 → 나중에 호출할 때 ref.current 읽기 → 최신 값","refs":["ref/react/packages/react-devtools-shared/src/devtools/views/Profiler/SnapshotCommitList.js:105-114"],"links":[],"ts":"2026-03-02T02:32:33.845Z"}
{"phase":1,"type":"qa","userQuestion":"즉 useMemo 안의 클로저 변수는 concurrent copy마다 독립적이지만, useRef는 Fiber에 저장되므로 모든 concurrent 렌더가 같은 ref를 공유합니다 << 무슨말인지 이해가 안갑니다\n\n\"concurrent copy마다\" -> 이게 뭔가요? / 모든 concurrent 렌더가 같은 ref를 공유 -> 같은 update일때는 그 update 범위에서 ref가 같은 참조라는거죠?\n\n(추가) 이건 이전에 배웠던 ref는 렌더중 읽거나 쓰지 마라 라는 규칙과 연관된거같네요","aiAnswer":"concurrent copy = Concurrent Mode에서 같은 컴포넌트를 다른 우선순위로 동시에 렌더하는 시도들. 예: input 타이핑(긴급) + 리스트 필터링 transition(낮은 우선순위).\n\nuseRef는 Fiber에 저장되므로 컴포넌트 인스턴스당 1개. 같은 update 범위가 아니라 모든 렌더 시도가 같은 ref를 봄. useMemo 클로저는 deps 변경시 새로 생성되므로 렌더 시도마다 독립.\n\nuseSyncExternalStoreWithSelector에서 useRef 대신 useMemo 클로저를 쓴 이유: 렌더 시도 A가 ref에 쓴 값이 렌더 시도 B를 오염시키는 문제 방지.\n\n사용자 추가 연결: 정확함. 이전 학습의 \"렌더 중 ref 읽기/쓰기 금지\" 원칙의 다른 표면. 근본 원인 동일: ref.current는 mutable이고 React가 관리하지 않으므로 concurrent 환경에서 값 일관성 보장 불가.","refs":["ref/react/packages/use-sync-external-store/src/useSyncExternalStoreWithSelector.js:50-53"],"links":[],"ts":"2026-03-02T02:39:40.897Z"}
{"phase":1,"type":"phase_end","summary":"useRef 실무 패턴 7가지 탐색: 1) 타이머 관리(sentinel -1, clearTimeout 안전성), 2) Observer 연동(cleanup 캡처 패턴, ref 2개 역할 분리), 3) 이전 값 추적(usePrevious 타이밍), 4) 최신 콜백 참조(지연 읽기), 5) DOM 명령형 제어(focus/scroll), 6) 렌더 중 Lazy init(멱등 초기화), 7) 외부 lib 인스턴스. 추가로 useMemo 클로저 vs useRef 선택 기준(concurrent copy 독립성)을 useSyncExternalStoreWithSelector 소스에서 확인. 이전 학습의 '렌더 중 ref 읽기/쓰기 금지' 원칙과 연결됨.","ts":"2026-03-02T02:39:56.876Z"}
{"phase":2,"type":"qa","userQuestion":"Q1: 리스트 렌더링 하는 상황 -> 이전에는 <div#A> 참조 중이였음 -> cleanup도 <div#A> 클린업 기대 -> 리렌더링 -> 리스트 하나 추가됨 <div#B>를 클린업하게됨","aiAnswer":"방향은 맞음. 보완: Fragment ref이므로 리스트보다 조건부 렌더링이 더 현실적. 그러나 가장 흔한 실제 버그는 언마운트 시 ref.current가 null이 되어 null.unobserve() → TypeError 발생. 캡처하면 두 문제 모두 방어: 1) DOM 변경 시 잘못된 DOM 정리 방지, 2) 언마운트 시 null 참조 방지.","refs":[],"links":[],"ts":"2026-03-02T02:48:00.060Z"}
{"phase":2,"type":"qa","userQuestion":"Q2에 대한 답: usePrevious에서 ref.current 변경은 useEffect 안(렌더 후)에 일어나므로 렌더 시도가 렌더 후랑 영향이 없다면, useMemo 문제 케이스랑 다를 것","aiAnswer":"정확함. 렌더 시도가 폐기되면 useEffect는 실행되지 않음. useEffect는 커밋된 렌더에 대해서만 실행. usePrevious는 읽기만 렌더 중에, 쓰기는 effect에서 하므로 concurrent copy 오염 문제 없음. 다만 React Compiler가 렌더 중 ref.current 읽기를 부수효과로 분류하므로 자동 메모이제이션 최적화가 제한됨. 동작은 하지만 권장하기엔 최적화와 충돌하는 패턴.","refs":[],"links":[],"ts":"2026-03-02T02:48:50.631Z"}
{"phase":2,"type":"phase_end","summary":"심화 A: cleanup 캡처 패턴 — React가 ref.current 변경을 추적하지 않는 이유(추적하면 state가 됨), cleanup 시 ref.current=null 문제(TypeError), 캡처로 두 문제 방어. 심화 B: usePrevious가 concurrent copy 오염에 안전한 이유 — 쓰기가 useEffect(커밋 후)에서만 발생하므로 폐기된 렌더 시도는 ref를 오염시키지 않음. 다만 React Compiler 최적화와 충돌하여 공식 API로 채택되지 않음.","ts":"2026-03-02T02:49:00.282Z"}
{"phase":3,"type":"coding","challengeType":"구현","challenge":"useDebounce(value, delay) 커스텀 훅 구현 — 디바운스된 값 반환, 타이머 ID는 ref로 관리, 언마운트 시 정리","userCode":"function useDebounce(value, delay) {\n    const [debouncedValue, setDebouncedValue] = useState(value)\n    const timeoutID = useRef(-1);           \n    useEffect(() => {\n      return function unmount() {\n        clearTimeout(timeoutID.current);    \n      };\n    }, []);\n    useCallback(\n      (...args) => {\n        clearTimeout(timeoutID.current);    \n        timeoutID.current = setTimeout(() => setDebouncedValue(value), delay, ...args);  \n      },\n      [value, delay],\n    );\n    return debouncedValue;\n  }","review":"1차: useDebounce(callback, ms) → 디바운스된 함수 반환으로 과제 의도(값 디바운스)와 다름. 2차 수정: useState 추가는 맞음. 문제점 — useCallback은 함수를 만들기만 하고 호출하지 않으므로 타이머 미시작. value 변경에 자동 반응해야 하므로 useEffect가 적합. 또한 cleanup이 언마운트 시에만 실행되어 이전 타이머 정리 안 됨(디바운스 핵심인 '이전 것 취소, 새로 시작' 미충족). 모범 답안: useEffect([value, delay]) 안에서 clearTimeout + setTimeout, return cleanup으로 매 변경마다 이전 타이머 정리.","result":"retry","ts":"2026-03-02T02:57:20.288Z"}
{"phase":3,"type":"phase_end","summary":"useDebounce 구현 과제. 1차 시도: useDebouncedCallback(함수 디바운스)을 작성하여 과제 의도(값 디바운스)와 불일치. 2차 시도: useState 추가했으나 useCallback으로 타이머를 걸어 호출이 안 됨. 핵심 학습: value 변경에 자동 반응 → useEffect, 함수 생성만 → useCallback. useEffect의 cleanup이 매 deps 변경마다 실행되는 점이 디바운스의 '이전 타이머 취소' 역할.","ts":"2026-03-02T02:57:24.074Z"}
{"phase":4,"type":"checkpoint","q1":"Observer 패턴의 cleanup에서 ref.current를 직접 사용하지 않고 캡처하는 이유는?","q1Answer":"캡쳐하지 않으면 동시 렌더링에서 렌더 폐기된 렌더에서 ref.current가 오염되었을수있고, ref는 Fiber내 참조가 공유되므로 오염된 값을 참조할 위험 존재","q2":"React 팀이 usePrevious를 공식 API로 만들지 않은 이유에 대한 생각은?","q2Answer":"usePrevious는 이전값을 저장하고 보통 그 이전값은 렌더링에 사용됩니다. 하지만 ref는 렌더링에 관여되지 않는 값을 위한 훅입니다","aiFeedback":"Q1: concurrent 오염 개념을 적용했으나 cleanup 캡처의 주된 이유는 커밋 후 타이밍 문제(cleanup 실행 시 ref.current가 이미 새 값으로 갱신됨 + 언마운트 시 null). 렌더 중 문제가 아닌 커밋 후 문제. Q2: useRef의 설계 의도와 usePrevious 사용의 모순을 정확히 짚음. 보충 — React Compiler가 렌더 중 ref.current 읽기를 부수효과로 분류하므로 자동 메모이제이션 최적화 제한.","result":"PASS","ts":"2026-03-02T03:00:34.604Z"}
{"phase":5,"type":"complete","ts":"2026-03-02T03:01:39.359Z"}
