# Mini-Forge: beginWork 분기 트리 6가지 조합 추적
> 날짜: 2026-02-27
> 세션: #2
> 체크포인트: PASS

## 원칙
> beginWork의 모든 bailout/리렌더링 판정은 `didReceiveUpdate` 단일 플래그의 설정·override·최종 체크라는 3단계 게이트를 통과한다.

**근거**: `ReactFiberBeginWork.js:4195` (설정), `:557` (override), `:1518` (최종 체크)
**나라면**: SimpleMemoComponent/MemoComponent를 통합하여 모든 memo 컴포넌트가 shallowEqual 먼저 → hooks 2차 기회를 갖게 하고 싶지만, MemoComponent의 래퍼 Fiber에는 hooks가 없어 renderWithHooks 불가능 — forwardRef/lazy 같은 비-함수 타입을 지원하려면 래퍼 Fiber가 구조적으로 필요하므로 현재 분리가 합리적.

## 판단 시나리오

### 상황 1: memo 컴포넌트가 context를 구독하는데 리렌더링이 예상보다 많다
**떠올려**: SimpleMemoComponent는 shallowEqual 먼저 → context 변경 시에도 hooks 결과가 같으면 bailout 가능. 하지만 `React.memo(comp, customCompare)`처럼 커스텀 비교를 넘기면 MemoComponent 경로 → context 변경 시 compare 자체를 스킵하여 무조건 리렌더링.
**안티패턴**: context를 구독하는 memo 컴포넌트에 불필요한 커스텀 compare를 전달하면, SimpleMemoComponent 승격이 차단되어 context 변경 시 2차 bailout 기회를 잃는다.

### 상황 2: memo 컴포넌트의 자식이 불필요하게 리렌더링된다
**떠올려**: SimpleMemoComponent는 shallowEqual 통과 시 `pendingProps = prevProps`로 참조를 교체한다 (`:574`). 이 교체가 있어야 자식 beginWork에서 `oldProps === newProps` → 가장 싼 early bailout(switch 진입조차 안 함)이 연쇄 발동.
**안티패턴**: memo 컴포넌트에 defaultProps를 추가하면 SimpleMemoComponent 승격이 차단되고, MemoComponent 경로에서는 이 참조 교체가 다르게 동작하여 연쇄 bailout 패턴이 달라진다.

## 기억법
"참조 문지기 → 값 문지기 → hooks 배심원" — beginWork의 3단 심사: 참조 비교(가장 싸고 빠른 문지기) → shallowEqual/compare(값 문지기, memo만 통과) → renderWithHooks 후 didReceiveUpdate 최종 판정(배심원, SimpleMemo만 2차 기회)
