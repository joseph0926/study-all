{"phase":0,"type":"init","topic":"beginWork 분기 트리 6가지 조합 추적","refDirs":["ref/react/"],"ts":"2026-02-27T03:56:36.441Z"}
{"phase":1,"type":"qa","userQuestion":"didReceiveUpdate = true 가 \"리렌더링해\"의 의사코드라 봐도될까요?\n\n---\n\n조합 1과 3 모두 renderWithHooks 실행으로 didReceiveUpdate = true가 그대로 되는건 동일하지만 renderWithHooks 실행 이유는 다른거죠? 조합 1은 함수 컴포넌트 실행 / 조합 3은 컨텍스트 실행\n\n---\n\n하지만 hooks 결과가 이전과 동일하면 → bailoutHooks → bailout 가능! << 이게 무슨말인가요? 코드로 보여주실수있나요?\n\n---\n\nSimpleMemoComponent와 MemoComponent의 체크 순서가 정반대 << 둘의 분기가 나뉘는 기준이 뭔가요?","aiAnswer":"**Q1 didReceiveUpdate = true = 리렌더링?**: 거의 맞지만, 정확히는 \"리렌더링 의향 플래그\". SimpleMemoComponent가 shallowEqual 통과 시 false로 override 가능(ReactFiberBeginWork.js:557). 최종 판정은 updateFunctionComponent의 :1518에서 `current !== null && !didReceiveUpdate` 체크. memo 없는 FunctionComponent에서는 아무도 false로 안 바꾸므로 사실상 \"리렌더링해\" 맞음.\n\n**Q2 조합 1과 3의 renderWithHooks 실행 이유**: 둘 다 같은 이유, 같은 경로. 부모 리렌더링 → oldProps !== newProps → Branch A → didReceiveUpdate=true → updateFunctionComponent → renderWithHooks. context 변경은 Branch A에서 영향 없음. checkScheduledUpdateOrContext는 Branch B(oldProps === newProps)에서만 호출됨. memo 없는 FunctionComponent에서 context가 영향주는 시나리오는 부모 bailout 시뿐.\n\n**Q3 hooks 결과 동일하면 bailout**: 조합 4-A에서 SimpleMemoComponent → shallowEqual✓ → didReceiveUpdate=false → context 변경 있음 → updateFunctionComponent(didReceiveUpdate=false) → renderWithHooks 실행 → hooks 내부에서 markWorkInProgressReceivedUpdate() 호출 여부로 판정. ReactFiberHooks.js:1539에서 useState/useReducer의 newState !== oldState면 markWorkInProgressReceivedUpdate() → didReceiveUpdate=true → 리렌더링. 모든 hooks 결과 동일하면 didReceiveUpdate=false 유지 → :1518에서 bailoutHooks → bailoutOnAlreadyFinishedWork → BAILOUT. 단, 함수 자체는 실행됨 — bailout은 reconcileChildren만 스킵.\n\n**Q4 SimpleMemo vs Memo 분기 기준**: mount 시 updateMemoComponent(:478-500)에서 4가지 조건 체크: (1) typeof type === 'function', (2) !shouldConstruct(type) = 클래스 아님, (3) type.defaultProps === undefined, (4) Component.compare === null. 모두 충족 → SimpleMemoComponent(tag=15, Fiber 1개 통합). 하나라도 불충족 → MemoComponent(tag=14, Fiber 2개). 체크 순서 정반대인 이유: SimpleMemo는 직접 hooks 가짐 → shallowEqual 후 context 있어도 renderWithHooks로 2차 기회. MemoComponent는 래퍼 Fiber에 hooks 없음 → context 변경이면 compare 무의미 → 먼저 체크하여 불필요한 compare 절약.","refs":["ReactFiberBeginWork.js:557","ReactFiberBeginWork.js:1518-1521","ReactFiberBeginWork.js:4196-4216","ReactFiberHooks.js:724","ReactFiberHooks.js:1539","ReactFiberHooks.js:1616","ReactFiberHooks.js:1763","ReactFiberBeginWork.js:478-500","ReactFiber.js:312-317"],"links":[],"ts":"2026-02-27T04:10:06.100Z"}
{"phase":1,"type":"phase_end","summary":"beginWork 분기 트리 6가지 조합을 소스코드 기반으로 완전 추적. Branch A(oldProps !== newProps) 진입 후 FunctionComponent/SimpleMemoComponent/MemoComponent 각각의 코드 경로, didReceiveUpdate 플래그의 설정·override·최종 판정 메커니즘, SimpleMemoComponent vs MemoComponent의 체크 순서 차이(shallowEqual 먼저 vs context 먼저)와 그 구조적 이유(Fiber 1개 vs 2개), markWorkInProgressReceivedUpdate를 통한 hooks 내부 bailout 가능성까지 추적.","ts":"2026-02-27T04:12:52.309Z"}
{"phase":2,"type":"qa","userQuestion":"shallowEqual 통과 시 새 props 객체를 이전 props 객체로 교체합니다 << 이미 새 props와 이전 Props 참조가 같다고 판정되어 진행된거 아닌가요? 근데 이걸 보정하기 위해 다시 이전 props 활용한다는게 무슨말인가요?\n\n---\n\n위 트리 시각화를 보니까 / 가장 싼 분기는 oldProps === newProps로 비교전에 끝내버리는게 제일 싸보이는데 맞나요? > 그럼 이러한 경우는 어떠한 경우인가요?\n\n---\n\nQ1: \"어차피 컴포넌트를 평가할 거니까 lanes를 비워도 된다\" 라는 가정에 SimpleMemoComponent가 해당되지 않기때문 -> switch에서 bailout되므로\nQ2: 모르겠습니다, 아마 자식 컴포넌트 bailout때문이거같은데 제 말로 루프백 못하겠습니다","aiAnswer":"**보충1 1 - props 객체 교체**: oldProps !== newProps인 상황(Branch A)에서 진행된 것. 부모 리렌더링 → 새 JSX → 새 props 객체(참조 B) vs 이전 props(참조 A). 참조는 다르지만 shallowEqual 통과(값 동일). 이때 pendingProps를 참조 B→참조 A로 교체하면, 자식 beginWork에서 oldProps === newProps → 가장 싼 early bailout 가능. 교체 안 하면 자식이 Branch A로 빠져 불필요한 리렌더링.\n\n**보충 2 - 가장 싼 분기**: 맞음. oldProps === newProps → early bailout이 가장 싸다(switch 진입 X, 함수 실행 X). 이 경우는 부모가 bailout되어 cloneChildFibers로 자식 Fiber를 클론할 때 발생. createWorkInProgress(currentChild, currentChild.pendingProps)로 같은 props 참조 유지 → 자식 beginWork에서 참조 동일 → early bailout. 이것이 subtree bailout 최적화 — 부모 bailout → 자식 전체 도미노 bailout.\n\n**Q1 정답**: lanes 복원이 필요한 이유 정확. beginWork에서 lanes=NoLanes 초기화는 '컴포넌트 평가 시 update queue 처리' 가정인데 SimpleMemoComponent는 평가 없이 bailout 가능. 복원 없으면 다른 우선순위 업데이트 유실.\n\n**Q2 피드백**: 방향 맞음. 정답은 Fiber 구조 차이. SimpleMemoComponent(Fiber 1개): current.memoizedProps = 실제 컴포넌트 props. MemoComponent(Fiber 2개): 래퍼 Fiber의 memoizedProps는 memo 래퍼 props(type, compare 포함)이지 실제 props가 아님 → currentChild(자식 Fiber)의 memoizedProps를 비교해야 함.","refs":["ReactFiberBeginWork.js:559-574","ReactFiberBeginWork.js:590","ReactFiberBeginWork.js:4248-4253","ReactChildFiber.js:2127","ReactFiber.js:327-357","ReactFiberBeginWork.js:3797-3800","ReactFiberBeginWork.js:515-528"],"links":[],"ts":"2026-02-27T04:27:37.624Z"}
{"phase":2,"type":"qa","userQuestion":"MemoComponent와 SimpleMemoComponent 가 너무 헷갈리는데 좀더 쉽게 설명가능할까요? (특히 props 부분)","aiAnswer":"택배 포장 비유로 설명.\n\nSimpleMemoComponent = 선물을 직접 손에 들고 있는 사람. Fiber 1개. current.memoizedProps가 바로 실제 props. shallowEqual로 자기 손에 든 걸 바로 비교.\n\nMemoComponent = 선물을 상자에 넣어서 들고 있는 사람. Fiber 2개(래퍼 + 자식). 래퍼 Fiber의 memoizedProps는 memo 라벨(type, compare 등)이지 실제 props가 아님. 실제 props는 currentChild.memoizedProps에 있음. 그래서 상자를 열어서(자식 Fiber에서) 비교.\n\n분기 기준: mount 시 X가 순수 함수 + defaultProps 없음 + 커스텀 compare 없음 → SimpleMemoComponent(상자 필요 없음). 하나라도 불충족(forwardRef, 커스텀 compare, defaultProps) → MemoComponent(상자 필요).\n\n비교 순서 차이: SimpleMemo는 shallowEqual 먼저(직접 들고 있으니 바로 비교) → context 나중. MemoComponent는 context 먼저(상자 열어봐야 하니 열 필요 있는지 먼저 확인) → compare 나중.","refs":["ReactFiberBeginWork.js:478-500","ReactFiberBeginWork.js:539-610","ReactFiberBeginWork.js:515-528","ReactFiber.js:312-317"],"links":[],"ts":"2026-02-27T04:30:15.659Z"}
{"phase":2,"type":"qa","userQuestion":"래퍼 제거보단, 래핑안함이 맞지않나요?","aiAnswer":"실제로는 \"래퍼 제거\"가 맞습니다. React.memo() 호출 → REACT_MEMO_TYPE element 생성 → createFiberFromTypeAndProps → MemoComponent(tag=14) Fiber로 생성됨. 그 다음 첫 mount 시 updateMemoComponent 안에서 isSimpleFunctionComponent 충족 → workInProgress.tag = SimpleMemoComponent(15)로 교체, workInProgress.type = 원본 함수로 교체. 처음에는 MemoComponent로 생성되었다가 mount 시 래퍼를 벗기고 단일 Fiber로 전환. ReactFiberBeginWork.js:488-489.","refs":["ReactFiberBeginWork.js:488-489"],"links":[],"ts":"2026-02-27T04:34:10.209Z"}
{"phase":2,"type":"phase_end","summary":"SimpleMemoComponent vs MemoComponent의 props 비교 대상 차이(current.memoizedProps vs currentChild.memoizedProps)를 Fiber 구조(택배 포장 비유)로 심화. props 객체 참조 교체(:574)가 자식 연쇄 bailout을 가능케 하는 메커니즘, cloneChildFibers의 참조 보존으로 subtree bailout 최적화, lanes 복원(:590)의 필요성(업데이트 유실 방지), SimpleMemoComponent가 mount 시 MemoComponent에서 래퍼 제거로 전환되는 정확한 시점 확인.","ts":"2026-02-27T04:34:23.824Z"}
{"phase":3,"type":"checkpoint","q1":"부모 컴포넌트가 리렌더링되었을 때, React.memo로 감싼 자식 컴포넌트의 beginWork 진입부터 최종 판정까지의 전체 흐름을 설명해주세요. (1) beginWork 진입 시 첫 번째로 무엇을 비교하나요? 그 결과는? (2) 그 다음 SimpleMemoComponent와 MemoComponent 각각에서 어떤 순서로 체크가 일어나나요? (3) props 값이 동일한데 context가 변경된 경우, SimpleMemoComponent와 MemoComponent의 결과가 왜 다른가요?","q1Answer":"Q1:\n1. beginWork는 첫번째로 oldProps와 newProps를 비교함 -> 결과에 따라 즉시 bailout이 될수도있고, false면 복잡한 분기로 들어감 (switch)\n2. updateMemoComponent에서 SimpleMemoComponent인지 체크 (typeof type === function / 클래스컴포넌트 아님, 커스텀 compare함수 없음 / defaultProps없음) 만족시 SimpleMemoComponent로 판정하여 memo 래퍼 제거\n3. SimpleMemoComponent는 hooks가 동일하면 context 변경되어도 리렌더링 건너뛸 기회가있지만 일반 Memo는 hooks가 없기때문에 무조건 리렌더","q2":"현재 React는 SimpleMemoComponent와 MemoComponent 두 가지 경로를 유지하고 있습니다. 만약 당신이 설계한다면, 이 두 경로를 하나로 통합했을까요? 아니면 현재처럼 분리를 유지했을까요? 트레이드오프를 포함해서 답해주세요.","q2Answer":"나라면? Memo가 default가 아니라 SimpleMemo를 default로 할것 -> 래핑 제거가 추가작업이 아니라 래퍼 추가가 추가작업이 되게, 이유: SimpleMemo가 되는 조건이 현대 React앱에서는 더 일반적으로 보임","aiFeedback":"Q1 피드백: 1번 맞음. 2번 시점 틀림 — SimpleMemoComponent 판정(4가지 조건)은 mount 시 1회만. update에서는 이미 tag 고정. 질문은 update 경로의 체크 순서를 물었음: SimpleMemo는 shallowEqual 먼저→context 나중, MemoComponent는 context 먼저→compare 나중. 3번 정확.\n\nQ2 피드백: 방향 흥미롭지만 구조적 제약 있음. React.memo() 호출 시 REACT_MEMO_TYPE element 생성 → Fiber 생성 시점에서는 조건 검사 불충분 → mount 시점에서야 판단. SimpleMemo를 default로 하려면 element→Fiber 파이프라인 변경 필요. 또한 MemoComponent는 래퍼 Fiber에 hooks 없어 renderWithHooks 불가 → 2차 기회 구조적 불가능. 통합하려면 Fiber 구조를 하나로 만들어야 하지만 forwardRef/lazy 등 비-함수 타입 지원에 래퍼 필요.","result":"PASS","ts":"2026-02-27T04:42:59.306Z"}
{"phase":5,"type":"complete","ts":"2026-02-27T04:48:39.095Z"}
