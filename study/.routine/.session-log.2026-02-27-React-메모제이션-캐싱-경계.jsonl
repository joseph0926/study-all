{"phase":0,"type":"init","topic":"React 메모제이션/캐싱 경계","refDirs":["ref/react/","ref/react.dev/"],"ts":"2026-02-26T22:59:06.425Z"}
{"phase":1,"type":"qa","userQuestion":"react의 메모제이션, 캐싱은 어디까지 커버하고 어디는 사용자에게 위임할까요? 또한 그 경계 판단과 그 이유, 근거들은 뭘까요?","aiAnswer":"React의 메모제이션 경계는 크게 3계층으로 나뉩니다.\n\n**자동 bailout (무료)**: beginWork에서 oldProps !== newProps 참조 비교(O(1)). props 참조 동일 + context 미사용/동일 + setState 없음 + ref 동일이면 자동 bailout.\n\n**수동 opt-in (유료)**: 부모 리렌더링 시 거의 항상 새 props 객체 생성되므로 === 실패. React.memo(shallowEqual), useMemo/useCallback(areHookInputsEqual), React.cache(Trie 구조) 필요.\n\n**React Compiler 자동화**: escape 분석(MemoizationLevel 4단계)으로 참조 안정성 자동 보장. 단, 비싼 계산 캐싱은 사용자 영역.\n\n경계 근거 4가지: (1) 기본을 안전하게(정확성 우선), (2) shallowEqual이 항상 이득은 아님, (3) Context는 bailout을 뚫음, (4) React Compiler가 자동화.","refs":["ReactFiberBeginWork.js:4187-4192","ReactFiberBeginWork.js:3874-3891","ReactMemo.js:12-58","ReactFiberHooks.js:2935-2960","PruneNonEscapingScopes.ts"],"links":[],"ts":"2026-02-26T23:02:35.885Z"}
{"phase":1,"type":"qa","userQuestion":"- 저 일련의 확인 루틴을 컴포넌트가 매번 렌더링될때마다 수행되는건가요?\n- shallowEqual 비교 자체가 오히려 오버헤드 << 어느정도의 오버헤드가 있나요?\n- useContext를 쓰면 Context 값 변경 시 무조건 리렌더링 << Object.is로 비교하는게 핵심같은데 이게 왜 memo를 뚫나요?\n- SimpleMemoComponent로 업그레이드하여 오버헤드 최소화 << 자세히 설명해주세요","aiAnswer":"**Q1 bailout 매번 수행?**: 네, 매 렌더링 사이클마다 해당 Fiber에 대해 수행. 단, 1차(O(1) 참조 비교)에서 90% 끝남. 공항 보안 검색대 비유 — 1차 금속탐지기(=== 비교)에서 대부분 통과.\n\n**Q2 shallowEqual 오버헤드**: Object.keys() x2 배열 할당 + hasOwnProperty.call() x N + Object.is() x N = O(N) + 배열 2개 GC. props 5-10개면 무시 가능하지만, '비교 비용 > 렌더링 비용' 역전이 대부분 컴포넌트에서 발생하므로 기본 적용 안 함.\n\n**Q3 Context가 memo 뚫는 이유**: 비교 자체가 문제가 아니라 비교 시점/위치 문제. checkScheduledUpdateOrContext가 true면 shallowEqual 자체를 실행하지 않고 직행 리렌더링. propagateContextChanges가 소비자 Fiber의 lanes에 직접 렌더링 예약. '호텔 전관 방송' 비유.\n\n**Q4 SimpleMemoComponent**: 순수 함수 + 커스텀 compare 없음 + defaultProps 없음 조건 충족 시 Fiber 2개(래퍼+자식) → 1개로 통합. beginWork 1번 호출, 메모리 절반. shallowEqual true면 이전 props 객체 재사용하여 연쇄 bailout 가능.","refs":["ReactFiberBeginWork.js:4187-4216","shallowEqual.js:18-52","ReactFiberBeginWork.js:515-528","ReactFiberNewContext.js:501-522","ReactFiber.js:312-318","ReactFiberBeginWork.js:539-610"],"links":[],"ts":"2026-02-26T23:08:11.691Z"}
{"phase":1,"type":"qa","userQuestion":"- 그런데 부모가 리렌더링되면? JSX가 새 props 객체를 생성하므로 자식의 1차 검사(===)가 실패합니다. 이것이 React.memo가 필요한 이유입니다. << 근데 갑자기 든 생각인데 / shallowEqual의 값이 비싸다면 그냥 리렌더링하는게 더 쌀수도있는거 아닐까요?\n- \"React.memo의 props 비교보다 우선순위가 높습니다.\" << 그러면 Context를 useMemo등으로 최적화하는것과는 지금 설명은 연관이 있나요?\n- \"defaultProps가\" << defaultProps가 정확히 뭔가요? 일반 props와는 달라보입니다\n- \"React는 래퍼 Fiber를 제거하고 1개 Fiber로 통합하여 순회 비용을 절반으로 줄입니다. 대부분의 React.memo 사용이 이 경로에 해당합니다.\" << 이말은 즉 memo 래퍼 Fiber를 제거하고 하위 컴포넌트를 모두 1개의 Fiber로 통합한다는뜻인가요?","aiAnswer":"**Q1 shallowEqual vs 리렌더링 비용 역전**: 정확한 지적. React.memo가 이득이려면 (1) 렌더링 비용이 비싸고 (2) bailout 성공률이 높아야 함. React 팀: '기본을 정확성(항상 리렌더링)으로 놓겠다' = opt-in 이유.\n\n**Q2 Context useMemo 최적화**: 직접적 연관. Provider에서 useMemo로 value 참조 유지 → propagateContextChanges 자체 방지(근본 차단). Consumer의 React.memo는 무력화됨. 'Context 최적화는 소비자가 아니라 공급자에서.'\n\n**Q3 defaultProps**: 컴포넌트 함수 객체의 정적 프로퍼티. React reconciler가 매 렌더링마다 새 props 객체 생성하여 병합 → SimpleMemoComponent의 참조 재사용 불가. ES6 기본 매개변수는 JS 엔진이 구조분해 시점에 처리 → props 객체 안 건드림 → SimpleMemo 가능.\n\n**Q4 SimpleMemoComponent 범위**: '하위 모든 자식 통합'이 아님. memo 래퍼 Fiber 1개 + 실제 컴포넌트 Fiber 1개 = 총 2개 → 1개 Fiber로 합침. 하위 자식들은 그대로. Fiber의 tag를 MemoComponent → SimpleMemoComponent로, type을 원본 함수로 교체.","refs":["ReactFiberBeginWork.js:488","ReactFiberClassComponent.js:1200-1213","ReactFiberNewContext.js:501-522","shallowEqual.js:18-52"],"links":[],"ts":"2026-02-26T23:16:47.762Z"}
{"phase":1,"type":"qa","userQuestion":"\"Context 최적화는 소비자(Consumer)에서 React.memo가 아니라 공급자(Provider)에서 useMemo로 해야 합니다. 방어 지점이 완전히 다릅니다.\" << 아 Context 내부에서 useMemo 최적화하는건 Context 처리 로직으로 들어갔을때의 최적화이고, Context 영향받는 컴포넌트의 memo는 뭘해도 깨지는군요 (memo 체크를 애초에 무시하고 바로 context 분기로 들어가니,,)\n\n\"현대 React에서는 defaultProps 대신 ES6 기본 매개변수를 권장합니다\" << 이말은 props 넘겨주는쪽에서 Default 값을 설정하지 말고, 내부 매개변수에서 할당하라는뜻인가요?\n\nSimpleMemoComponent << 아직 잘 이해가안갑니다 SimpleMemoComponent가 가능하다고 판단되면 memo로 래핑된 컴포넌트와 직계 자식 컴포넌트가 합쳐진다는뜻인가요?","aiAnswer":"**Q1 Context+memo 무력화 확인**: 완전히 맞습니다. 층위 1(Provider useMemo → propagate 방지) vs 층위 2(Consumer memo → 이미 lanes 주입되어 shallowEqual 스킵 → 무력화) 정리.\n\n**Q2 defaultProps vs ES6 기본 매개변수**: props 넘기는 쪽이 아니고 컴포넌트 함수 객체의 정적 프로퍼티. defaultProps는 React reconciler가 처리(매번 새 객체), ES6 기본 매개변수는 JS 엔진이 구조분해 시 처리(원본 props 객체 유지). 처리 시점/주체가 다름.\n\n**Q3 SimpleMemoComponent 상세**: 코드를 React.memo() 호출 → Fiber 생성 → mount 시 갈림길로 step-by-step 추적. 경로 A: isSimpleFunctionComponent 충족 → workInProgress.tag = SimpleMemoComponent, workInProgress.type = resolvedType로 교체 → 자식 Fiber 생성 안 함. 경로 B: 자식 Fiber 별도 생성. 'memo 래퍼와 원본 컴포넌트 함수가 하나의 Fiber에서 처리된다'가 정확한 표현.","refs":["ReactFiberBeginWork.js:478-512","ReactFiberBeginWork.js:4338-4346","ReactFiber.js:657-659","ReactFiberClassComponent.js:1200-1213"],"links":[],"ts":"2026-02-26T23:23:14.623Z"}
{"phase":1,"type":"phase_end","summary":"React 메모제이션/캐싱 경계 탐색 완료. 자동 bailout(props 참조 ===) vs 명시적(React.memo/useMemo/useCallback) 경계, shallowEqual 비용 역전 논리, Context가 memo를 뚫는 메커니즘(lane 강제 주입→shallowEqual 스킵), SimpleMemoComponent 승격(Fiber 2→1 통합), defaultProps vs ES6 기본 매개변수의 참조 보존 차이를 소스코드 근거로 탐색.","ts":"2026-02-26T23:25:38.460Z"}
{"phase":2,"type":"qa","userQuestion":"Q1: 원시값은 절대 메모하지 않는 이유를 Object.is와 연결해서 설명해보세요.\nA1: Object.is의 비용은 O(1)입니다. 매우 싸기때문에 굳이 메모제이션하지 않습니다. 이득이 별로없으니\n\nQ2: sorted = [...items].sort() 후 console.log(sorted.length)만 하고 return <div>{items.length}개</div> 일 때 sorted를 메모하나?\nA2: [...items] < 새배열 (Memoized level) / .sort() < 함수 호출 (Memoized level) => 메모할거같습니다","aiAnswer":"**Q1 정답**: 원시값은 비교가 싼 것뿐 아니라 메모해도 효과가 없는 것이 더 근본적. 같은 값이면 Object.is가 항상 true → '같은 내용이지만 다른 참조' 문제 자체가 없음.\n\n**Q2 메모하지 않습니다**: Level 분류는 맞지만 escape 여부가 빠짐. sorted는 return에 없고 console.log는 Hook이 아님 → escape 안 함 → 메모 불필요. '메모 결정 = Level(Memoized/Conditional) AND escape(return/Hook)'. MemoizationLevel은 '메모 가능한 종류인가', escape 분석은 '메모 필요가 있는가'. 둘 다 충족해야 메모.","refs":["PruneNonEscapingScopes.ts:146-158","PruneNonEscapingScopes.ts:280-347"],"links":[],"ts":"2026-02-26T23:35:32.878Z"}
{"phase":2,"type":"qa","userQuestion":"그러면 위 예시에서 return <div>{sorted.length}개</div>; 면 메모하나요? return되니 메모해야할거같은데, sorted.length는 원시값이라,,","aiAnswer":"**sorted를 메모하지 않습니다.** sorted.length는 원시값(Never level) → 메모 안 함. sorted 자체는 return에 안 나옴 → escape 안 함. escape 추적은 '참조가 외부로 나가는가'를 봄. sorted → .length → return에서 sorted의 참조는 나가지 않고 원시값만 나감. Compiler의 메모제이션 목적은 '참조 안정성'이지 '비싼 계산 캐싱'이 아님. 비싼 계산 캐싱은 여전히 useMemo 사용자 영역.","refs":["PruneNonEscapingScopes.ts"],"links":[],"ts":"2026-02-26T23:37:03.590Z"}
{"phase":2,"type":"qa","userQuestion":"\"sort()가 비싸더라도 Compiler 입장에서는 '어차피 결과 참조를 아무도 안 쓰니까' 메모하지 않습니다\" << 근데 그러면 이 컴포넌트가 리렌더링될때마다 sorted는 재생성되지 않나요?","aiAnswer":"**네, 매 리렌더링마다 재생성됩니다.** Compiler는 의도적으로 허용. React Compiler의 목적은 '참조 안정성(referential stability)'이지 '비싼 계산 캐싱'이 아님. escape 안 하는 값은 메모해도 DOM 결과 동일하므로 캐시 슬롯 낭비. 비싼 계산이지만 참조가 외부 노출 안 되는 경우는 여전히 useMemo 사용자 영역.","refs":["PruneNonEscapingScopes.ts"],"links":[],"ts":"2026-02-26T23:39:24.388Z"}
{"phase":2,"type":"qa","userQuestion":"그러면 저런 놓치는?(의도적으로 안하지만 메모가 필요한 부분) 부분 체크는 직접해야합니까? 아니면 힌트라도주나요?","aiAnswer":"**직접 해야 합니다.** React Compiler는 힌트 없음(참조 안정성만 관심). React DevTools Profiler, Chrome Performance 탭, why-did-you-render 등으로 런타임 측정 필요. '비싼 계산'은 도메인 지식(items 크기, sort 비교함수 복잡도, 리렌더링 빈도)이라 정적 분석 한계. 실전 워크플로우: Compiler 적용(80%) → Profiler 측정 → 수동 useMemo(20%).","refs":[],"links":[],"ts":"2026-02-26T23:42:18.113Z"}
{"phase":2,"type":"phase_end","summary":"React Compiler의 escape 분석(MemoizationLevel 4단계 + escape 조건) 심화, useMemoCache vs useMemo 구조적 차이(flat 배열 vs hook linked list, atomic writes), Compiler의 메모제이션 목적(참조 안정성)과 한계(비싼 계산 캐싱은 사용자 영역), 원시값 Never 이유, escape 없는 객체 메모 제거 논리를 코드 기반으로 심화.","ts":"2026-02-26T23:43:03.699Z"}
{"phase":3,"type":"checkpoint","q1":"부모 컴포넌트가 리렌더링될 때, React.memo로 감싼 자식 컴포넌트의 bailout 판단이 일어나는 전체 흐름을 설명해주세요. beginWork에서 어떤 순서로 체크가 일어나는지, 어떤 조건에서 shallowEqual까지 도달하고 어떤 조건에서 그 전에 결정되는지, Context를 사용하는 경우 이 흐름이 어떻게 달라지는지.","q1Answer":"beginWork에서\n1. oldProps !== newProps 로 props가 다른지 체크\n2. 다르면 -> React.memo 있나 체크\n3. memo가 있어도 Context나 이미 등록된 스케쥴이있으면 리렌더링\n4. 3번도 통과하면 shollwEqual 체크\n\n---\n\nContext가 있으면\n1. meom 상관없이 context 분기로\n2. Object.is로 비교\n3. 다르면 리렌더링","q2":"React의 기본이 '모든 컴포넌트에 shallowEqual을 적용'이 아니라 'opt-in(React.memo)'인 설계를 바꿀 수 있다고 가정합시다. 만약 당신이 React를 설계한다면, 기본으로 모든 컴포넌트에 shallowEqual을 적용하고 opt-out하게 만들었을까요? 아니면 현재 설계(opt-in)를 유지했을까요? 트레이드오프를 포함해서 답해주세요.","q2Answer":"- 도메인 담당이라 앞선 예시 sorted를 메모제이션 안하는건 맞는 판단 같음\n- 근데 이미 opt-out를 리액트 컴파일러등을 도입한 시점에서 이 간극을 잡을 lint like를 도입하면,했으면 어땠을까?","aiFeedback":"**Q1 피드백**: 큰 흐름은 맞습니다. 보충: (1) Context 분기는 'memo 상관없이 별도 분기'가 아니라 memo 처리 함수(updateMemoComponent) 안에서 shallowEqual보다 먼저 체크하는 것. (2) Context의 Object.is 비교는 두 단계: Provider 렌더링 시 propagateContextChanges → 소비자 lanes에 예약(대부분 여기서 결정), 소비자 beginWork 시 lanes로 즉시 판정. checkIfContextChanged의 Object.is는 드문 경로(lazy propagation).\n\n**Q2 피드백**: sorted 메모 안 하는 판단 동의. lint-like 도구 제안에 대해 — '비싸다'의 기준 모호, false positive 폭발, 런타임 정보 없이 한계. React DevTools Profiler가 더 적합.","result":"FAIL","ts":"2026-02-26T23:54:00.462Z"}
{"phase":5,"type":"complete","ts":"2026-02-26T23:59:29.520Z"}
