{"phase":0,"type":"init","topic":"useRef 심화: 내부구현·ref callback·실무패턴","refDirs":["ref/react"],"ts":"2026-03-01T22:46:18.046Z"}
{"phase":1,"type":"qa","userQuestion":"1) currentlyRenderingFiber는 let null인데 언제 Fiber로 초기화되는가? 2) workInProgressHook = workInProgressHook.next = hook은 왜 workInProgressHook = hook으로 안 하는가? 3) fiber.memoizedState에 hook을 할당하는 거 아니었나? hook.memoizedState = ref는 객체를 할당하는데? 4) updateRef에서 매번 함수 호출이므로 최신값 보장은 되는가?","aiAnswer":"아래 전체 응답 참조 — 4개 질문에 대해 코드 근거와 시각화로 설명","refs":["ref/react/packages/react-reconciler/src/ReactFiberHooks.js:261","ref/react/packages/react-reconciler/src/ReactFiberHooks.js:511","ref/react/packages/react-reconciler/src/ReactFiberHooks.js:979-998","ref/react/packages/react-reconciler/src/ReactFiberHooks.js:1000-1068","ref/react/packages/react-reconciler/src/ReactFiberHooks.js:2602-2612"],"links":[],"ts":"2026-03-01T23:17:58.835Z"}
{"phase":1,"type":"qa","userQuestion":"2번(ref callback 패턴)으로 넘어가주세요","aiAnswer":"ref callback 패턴 설명: 3가지 ref 전달 방식, attach/detach 타이밍, commit phase에서의 동작, markRef의 참조 동일성 비교, 인라인 함수 함정, cleanup callback ref 패턴 — 코드 근거 포함 전체 설명","refs":["ref/react/packages/react-reconciler/src/ReactFiberCommitEffects.js:756-823","ref/react/packages/react-reconciler/src/ReactFiberCommitEffects.js:841-907","ref/react/packages/react-reconciler/src/ReactFiberBeginWork.js:1381-1400","ref/react/packages/react-reconciler/src/ReactFiberCommitWork.js:2092-2096","ref/react/packages/react-reconciler/src/ReactFiberCommitWork.js:630-695"],"links":[],"ts":"2026-03-01T23:22:29.475Z"}
{"phase":1,"type":"phase_end","summary":"useRef 내부 구현 심화: Hook 링크드 리스트 구조, currentlyRenderingFiber 초기화 타이밍(renderWithHooks), memoizedState 이중 레벨(Fiber vs Hook), ref 객체 참조 공유 메커니즘. ref callback attach/detach 흐름(markRef→commitAttachRef/safelyDetachRef) 설명했으나 사용자가 소화 어렵다고 판단하여 정리 요청.","ts":"2026-03-01T23:27:37.193Z"}
{"phase":4,"type":"checkpoint","q1":"mountWorkInProgressHook의 링크드 리스트 구조 때문에 Hook을 조건문 안에서 호출하지 못하게 하는 이유를 설명해주세요","q1Answer":"해당 구조 때문에 왜 조건문 안에서 호출못하나요?","q2":"useRef가 Hook 링크드 리스트에 {current: T}를 저장하는 방식 대신 다른 방식으로 ref 값을 저장할 수 있었을까요?","q2Answer":"글쎄요, Hook이라는 범위에서는 useRef가 맞지만, 리액트 흐름에서는 useRef는 벗어나있습니다. 그러면 굳이 Hook으로 묶어야하는가?","aiFeedback":"Q1: 링크드 리스트는 인덱스 없이 순서에만 의존하므로 조건문으로 Hook이 스킵되면 current의 N번째 노드와 wip의 N번째 호출이 불일치하여 데이터가 꼬임. Q2: 아주 좋은 지적. useRef는 queue/dispatch/리렌더 트리거가 없어 모듈 변수나 WeakMap으로도 가능하지만, Hook 리스트에 있으면 Fiber unmount 시 함께 정리되는 생명주기 바인딩 이점이 있음.","result":"PASS","ts":"2026-03-01T23:34:44.739Z"}
{"phase":5,"type":"complete","ts":"2026-03-01T23:34:49.156Z"}
