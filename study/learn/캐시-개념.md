# 캐시-개념

> 최초 질문: client,server 상관없이 개발에서의 캐시란 무엇일까요?
> 일시: 2026-02-26

---

## Q1. client/server 상관없이 개발에서의 캐시란 무엇일까요?

### 비유: 도서관의 책상 위 참고서 더미

| 캐시 개념 | 도서관 비유 |
|-----------|-----------|
| **원본 데이터(Origin)** | 도서관 서가 깊숙한 곳의 **원본 책** — 가서 꺼내오는 데 시간이 걸림 |
| **캐시(Cache)** | 내 책상 위에 올려놓은 **참고서 더미** — 이미 꺼내왔으니 바로 펼침 |
| **캐시 히트(Hit)** | 필요한 책이 책상 위에 **이미 있음** → 바로 읽음 |
| **캐시 미스(Miss)** | 책상에 없음 → 서가까지 **걸어가서 꺼내옴** → 책상에 올려둠 |
| **캐시 용량(Capacity)** | 책상 크기 — 올려놓을 수 있는 **책의 수에 한계**가 있음 |
| **퇴거(Eviction)** | 책상이 꽉 차면, **가장 오래 안 본 책**을 서가에 되돌림 (LRU) |
| **무효화(Invalidation)** | 책 내용이 **개정판**으로 바뀜 → 구판을 치우고 새 판을 가져옴 |
| **캐시 키(Key)** | "제목+판번호" — **어떤 책인지 식별**하는 라벨 |

핵심: 캐시 = **"비싼 연산/조회의 결과를 가까운 곳에 임시 저장해, 같은 요청이 오면 다시 계산하지 않고 재사용하는 것"**입니다. client든 server든, CPU 계산이든 네트워크 요청이든, 이 원리는 동일합니다.

### 1. 캐시의 본질 — 3가지 핵심 구성 요소

어떤 캐시든 반드시 이 3가지를 결정해야 합니다:

**(1) 키(Key) — "무엇을 기준으로 같은 요청인지 판단하는가?"**

React의 `cache()` 구현을 보면, 인자 하나하나를 트리 구조로 타고 들어가며 키를 구성합니다:

```js
// ref/react-fork/packages/react/src/ReactCacheImpl.js:74-105
for (let i = 0, l = arguments.length; i < l; i++) {
  const arg = arguments[i];
  if (typeof arg === 'function' || (typeof arg === 'object' && arg !== null)) {
    // 객체/함수 → WeakMap (참조 동등성으로 키 매칭)
    let objectCache = cacheNode.o;
    if (objectCache === null) {
      cacheNode.o = objectCache = new WeakMap();
    }
    // ...
  } else {
    // 원시값 → Map (값 동등성으로 키 매칭)
    let primitiveCache = cacheNode.p;
    if (primitiveCache === null) {
      cacheNode.p = primitiveCache = new Map();
    }
    // ...
  }
}
```

비유 매칭: "제목+판번호"로 책을 찾는 것처럼, 함수 인자 조합이 캐시의 "라벨"이 됩니다. 객체는 참조(WeakMap), 원시값은 값(Map)으로 비교하는데, 이는 책의 식별 방식이 다른 것과 같습니다 — 희귀본은 고유 바코드(참조), 일반 도서는 ISBN(값)으로 찾는 것.

**(2) 저장소(Storage) — "결과를 어디에 보관하는가?"**

Next.js의 FileSystemCache를 보면 **2단계 저장소**를 사용합니다:

```ts
// ref/next.js/packages/next/src/server/lib/incremental-cache/file-system-cache.ts:50-56
if (ctx.maxMemoryCacheSize) {
  if (!FileSystemCache.memoryCache) {
    FileSystemCache.memoryCache = getMemoryCache(ctx.maxMemoryCacheSize)
  }
}
```

메모리(LRU) → 파일 시스템, 이중 계층입니다. 비유로는: 책상(메모리) → 서가(디스크). 책상에 없으면 서가에서 찾고, 서가에도 없으면 도서관 네트워크(원본 서버)에 요청합니다.

**(3) 만료/무효화(Invalidation) — "언제 오래된 데이터를 버리는가?"**

Next.js의 `getCacheControlHeader`가 이를 명확히 보여줍니다:

```ts
// ref/next.js/packages/next/src/server/lib/cache-control.ts:17-35
export function getCacheControlHeader({ revalidate, expire }: CacheControl): string {
  if (revalidate === 0) {
    return 'private, no-cache, no-store, max-age=0, must-revalidate'  // 캐시 안 함
  } else if (typeof revalidate === 'number') {
    return `s-maxage=${revalidate}${swrHeader}`  // N초 후 재검증
  }
  return `s-maxage=${CACHE_ONE_YEAR_SECONDS}${swrHeader}`  // 거의 영구 캐시
}
```

비유 매칭: 책에 "유효기간 스티커"를 붙이는 것입니다. `revalidate=0`은 "매번 서가에서 새로 가져와라", `revalidate=60`은 "60초 동안은 책상 것을 믿어라", `false`는 "이 책은 내용이 안 바뀐다"입니다.

### 2. 퇴거 전략 — LRU(Least Recently Used)의 실제 구현

책상이 꽉 차면 어떤 책을 치울까? Next.js의 LRU 캐시 구현이 정확히 이 문제를 해결합니다:

```ts
// ref/next.js/packages/next/src/server/lib/lru-cache.ts:46-47
// Hash Map + Doubly-Linked List → O(1) get/set/evict
export class LRUCache<T> {
  private readonly cache: Map<string, LRUNode<T>> = new Map()
  // HEAD <-> [most recent] <-> ... <-> [least recent] <-> TAIL
```

```ts
// ref/next.js/packages/next/src/server/lib/lru-cache.ts:154-160
// 용량 초과 시 꼬리(가장 오래 안 쓴 것)부터 제거
while (this.totalSize > this.maxSize && this.cache.size > 0) {
  const tail = this.removeTail()
  this.cache.delete(tail.key)
  this.totalSize -= tail.size
  this.onEvict?.(tail.key, tail.data)
}
```

비유 매칭: 책상 위 참고서를 **최근 펼쳐본 순서**로 쌓아둡니다. 새 책이 오면 맨 위에 올리고, 책상이 꽉 차면 맨 아래(가장 오래 안 본) 책을 서가에 돌려보냅니다. `get()`할 때마다 그 책을 맨 위로 올리는 것(`moveToHead`)이 핵심 트릭입니다.

### 3. 캐시의 보편적 패턴 — 어디에서든 동일

추론: client/server를 가리지 않고, 캐시의 본질은 항상 동일한 패턴을 따릅니다:

| 계층 | 비싼 것(Origin) | 싼 것(Cache) | 키 | 무효화 |
|------|----------------|-------------|-----|--------|
| **CPU 캐시** | 메인 메모리 접근 | L1/L2/L3 캐시 | 메모리 주소 | 캐시 라인 교체 |
| **브라우저 HTTP 캐시** | 서버 요청 | 디스크/메모리 | URL + 헤더 | `Cache-Control`, `ETag` |
| **React `cache()`** | 함수 재실행 | WeakMap/Map 트리 | 함수 인자 | 컴포넌트 생명주기 |
| **React `useMemo`** | 계산 재실행 | Fiber에 저장 | 의존성 배열 | deps 변경 시 |
| **Next.js ISR** | 페이지 재렌더 | 파일/메모리 | 경로 | `revalidate` 시간 |
| **DB 쿼리 캐시** | 디스크 I/O + 쿼리 | 메모리(Redis 등) | 쿼리 해시 | TTL, 수동 무효화 |
| **DNS 캐시** | 루트 서버 조회 | 로컬 리졸버 | 도메인명 | TTL |

### 시각화

```
요청 흐름 (어떤 캐시든 동일):

  ┌──────────┐     히트(Hit)      ┌──────────────────┐
  │  요청자   │ ──── key로 조회 ──→ │      캐시         │ ─── 결과 반환 ──→ 빠름!
  │(Client/  │                    │ (key→value 저장소) │
  │ Server)  │     미스(Miss)      └────────┬─────────┘
  │          │ ←─── 없음! ────────────────────┘
  │          │                               │
  │          │     원본 요청                    ↓
  │          │ ──────────────────→ ┌──────────────────┐
  │          │                    │   원본(Origin)     │
  │          │ ←── 결과 + 캐시 저장 │ (DB/API/계산/서버)  │
  └──────────┘                    └──────────────────┘


캐시의 3대 결정 사항:

  ┌─────────────────────────────────────────────┐
  │              캐시 설계 = 3가지 질문            │
  ├──────────────┬───────────────┬──────────────┤
  │   1. Key     │  2. Storage   │ 3. Invalidation │
  │  (뭘 기준으로  │  (어디에       │  (언제          │
  │   같다고      │   저장?)       │   버릴까?)      │
  │   판단?)     │               │               │
  ├──────────────┼───────────────┼──────────────┤
  │ URL, 인자,   │ 메모리, 디스크, │ TTL, 태그,     │
  │ 해시, deps   │ CDN, Redis    │ deps 변경,     │
  │              │               │ 수동 무효화     │
  └──────────────┴───────────────┴──────────────┘
```

---

## Q2. 캐시 개념은 단순한데, 왜 어려운 파트로 꼽히나?

### 비유 확장: "여러 지점이 있는 도서관 체인"

| 어려움 | 도서관 비유 |
|--------|-----------|
| **무효화 문제** | 본사에서 개정판이 나왔는데, **어느 지점 책상에 구판이 남아있는지** 전부 파악할 수 없음 |
| **일관성 문제** | A지점 책상에는 3판, B지점 책상에는 2판 — **누가 맞는 걸 보고 있는지** 모름 |
| **숨겨진 상태** | 고객이 "내용이 틀려요" 항의 → 서가 원본은 맞는데, **책상 위 구판** 때문. 원인 추적이 어려움 |
| **중첩 계층** | 지점 책상 → 지역 창고 → 중앙 서가. 지역 창고 것이 갱신됐는데 **지점 책상 것은 아직 구판** |
| **키 설계** | "React 입문서"와 "React 입문서 (2판)"을 **같은 책으로 봐야 하나, 다른 책으로 봐야 하나?** |

핵심: 캐시의 **넣는 것**은 쉽지만, **빼는 것(=무효화)**과 **여러 계층이 동시에 존재하는 상황**이 본질적 어려움입니다.

### 1. "무효화" — CS에서 가장 유명한 난제

> "There are only two hard things in Computer Science: cache invalidation and naming things." — Phil Karlton

Next.js의 태그 기반 무효화 코드가 이 어려움을 잘 보여줍니다:

```ts
// ref/next.js/packages/next/src/server/lib/incremental-cache/tags-manifest.external.ts:12-29
export const areTagsExpired = (tags: string[], timestamp: Timestamp) => {
  for (const tag of tags) {
    const entry = tagsManifest.get(tag)
    const expiredAt = entry?.expired
    if (typeof expiredAt === 'number') {
      const now = Date.now()
      const isImmediatelyExpired = expiredAt <= now && expiredAt > timestamp
      if (isImmediatelyExpired) return true
    }
  }
  return false
}
```

단순해 보이지만, 이 함수가 답해야 할 질문들이 폭발적으로 복잡합니다:
- `timestamp`(캐시 생성 시점)과 `expiredAt`(태그 무효화 시점)의 **시간 순서 비교** — 태그가 무효화된 게 캐시 생성 전인가, 후인가?
- `stale`과 `expired`가 **별도 개념** — stale은 "신선하지 않지만 아직 쓸 수 있음", expired는 "완전히 못 씀" (`areTagsStale` vs `areTagsExpired`)
- 태그 하나라도 만료되면 전체 캐시 엔트리가 무효 — **다대다 관계**

비유 매칭: 도서관에서 "의학 분야" 태그가 붙은 책 전부를 회수하라는 지시가 내려왔을 때, "이 책은 언제 책상에 올라왔고, 회수 지시는 그 전인가 후인가?"를 판단해야 하는 것과 같습니다.

### 2. "숨겨진 상태" — 디버깅의 악몽

캐시는 **보이지 않는 상태**를 시스템에 추가합니다. Next.js `use-cache-wrapper.ts`에서 이 주석이 핵심을 찌릅니다:

```ts
// ref/next.js/packages/next/src/server/use-cache/use-cache-wrapper.ts:158-161
// We need to run this inside a clean AsyncLocalStorage snapshot so that the cache
// generation cannot read anything from the context we're currently executing which
// might include request specific things like cookies() inside a React.cache().
```

```ts
// ref/next.js/packages/next/src/server/use-cache/use-cache-wrapper.ts:183-188
// Since we cleared the AsyncLocalStorage we need to restore the workStore.
// Note: We explicitly don't restore the RequestStore nor the PrerenderStore.
// We don't want any request specific information leaking
```

캐시 함수 안에서 `cookies()`를 읽으면 어떻게 될까? 사용자 A의 쿠키로 생성된 캐시를 사용자 B가 받게 됩니다. 그래서 Next.js는 캐시 생성 시 **RequestStore를 의도적으로 차단**합니다. 이런 **"캐시가 잡아먹으면 안 되는 것"**을 관리하는 것 자체가 복잡성의 원천입니다.

비유 매칭: 도서관에서 "이 책의 밑줄은 전 사용자가 긋은 것이지, 이 책의 원본 내용이 아닙니다"를 구분해야 하는 것. 캐시에 **요청별 맥락(쿠키, 인증)**이 섞여 들어가면 다른 사용자에게 잘못된 정보가 노출됩니다.

### 3. "중첩 계층" — 캐시 위의 캐시

Next.js의 `FileSystemCache.get()`을 보면:

```ts
// ref/next.js/packages/next/src/server/lib/incremental-cache/file-system-cache.ts:109-120
let data = FileSystemCache.memoryCache?.get(key)  // 1계층: 메모리
// ...
if (!data && process.env.NEXT_RUNTIME !== 'edge') {
  // 2계층: 디스크 파일
  const fileData = await this.fs.readFile(filePath, 'utf8')
```

그리고 `SharedCacheControls`는 또 다른 계층입니다:

```ts
// ref/next.js/packages/next/src/server/lib/incremental-cache/shared-cache-controls.external.ts:36-41
public get(route: string): CacheControl | undefined {
  let cacheControl = SharedCacheControls.cacheControls.get(route)  // 인메모리
  if (cacheControl) return cacheControl
  let prerenderData = this.prerenderManifest.routes[route]          // 매니페스트
```

중첩 캐시 문제 예시: `use cache` 안에 또 `use cache`를 넣으면?

```ts
// ref/next.js/packages/next/src/server/use-cache/use-cache-wrapper.ts:134-140
const nestedCacheZeroRevalidateErrorMessage =
  `A "use cache" with zero \`revalidate\` is nested inside another "use cache" ` +
  `that has no explicit \`cacheLife\`, which is not allowed during prerendering.`
```

Next.js는 **이런 중첩 자체를 에러로 잡아야** 했습니다. 바깥 캐시의 수명이 안쪽 캐시보다 길면, 안쪽이 만료돼도 바깥이 살아 있어서 구 데이터가 계속 서빙됩니다.

비유 매칭: 지점 책상(바깥 캐시)에 올린 노트에 "지역 창고 3번 선반(안쪽 캐시) 참조"라고 적혀 있는데, 창고 내용은 바뀌었지만 지점 노트는 그대로 — **어떤 계층이 stale인지 추적하는 것** 자체가 조합 폭발입니다.

### 4. "키 설계" — 동일성 판단의 함정

React `cache()`의 키 구성을 다시 봅니다:

```js
// ref/react-fork/packages/react/src/ReactCacheImpl.js:76-79
if (typeof arg === 'function' || (typeof arg === 'object' && arg !== null)) {
  // 객체 → WeakMap (참조 동등성)
} else {
  // 원시값 → Map (값 동등성)
}
```

`cache(fetchUser)({id: 1})`을 두 번 호출하면? `{id: 1} !== {id: 1}` (참조가 다름) → **캐시 미스**. 개발자는 같다고 생각하지만 캐시는 다르다고 판단합니다. 이것이 "예상과 다른 캐시 동작"의 전형적 원인입니다.

### 시각화: 캐시가 어려운 이유 계층도

```
           "캐시가 어려운 이유" 분류

  ┌──────────────────────────────────────────────────┐
  │              넣는 건 쉽다 (GET → MISS → STORE)    │
  └──────────────────────────────────────────────────┘
                        │
        ┌───────────────┼───────────────┐
        ▼               ▼               ▼
  ┌──────────┐   ┌──────────┐   ┌──────────┐
  │ 무효화    │   │ 일관성    │   │ 가시성    │
  │ (빼는 것) │   │ (맞추는것)│   │ (보는 것) │
  └────┬─────┘   └────┬─────┘   └────┬─────┘
       │              │              │
  ┌────┴────┐   ┌─────┴────┐   ┌────┴─────┐
  │시간 기반  │   │다계층 정합│   │디버깅 불가│
  │(TTL/stale│   │(메모리→   │   │(캐시 hit │
  │/expired) │   │ 디스크→   │   │ 인지 불가 │
  ├─────────┤   │ CDN→원본) │   ├──────────┤
  │태그 기반  │   ├──────────┤   │보안 누수  │
  │(다대다   │   │중첩 캐시  │   │(요청 맥락 │
  │ 추적)    │   │(inner가   │   │ 오염)     │
  ├─────────┤   │ outer보다 │   └──────────┘
  │키 동등성  │   │ 먼저 만료)│
  │(참조 vs  │   └──────────┘
  │ 값 비교) │
  └─────────┘
```

---

## Q3. 가장 큰 병목은 "타이밍"과 "판단"인 것 같은데 맞나요?

맞습니다. 그리고 이 두 가지가 **독립적이 아니라 서로 얽혀 있기 때문에** 더 어렵습니다.

### 비유: 도서관 사서의 딜레마

| 사서의 결정 | 타이밍 측면 | 판단 측면 |
|-----------|-----------|----------|
| "이 책을 책상에 얼마나 둘까?" | **stale/revalidate/expire 세 시계** 중 어떤 기준? | 이 책은 자주 바뀌는 종류인가, 아닌가? |
| "지금 구판을 줘도 될까?" | 개정판이 나온 지 **5초? 5분? 5일?** | 의학서적(치명적) vs 소설(무해) — **틀린 데이터의 비용**이 다름 |
| "두 사람이 동시에 같은 책을 요청하면?" | 서가까지 **한 번만** 가면 되는 건데 | 둘 다 보내면 낭비, 하나만 보내면 **나머지는 언제까지 기다려야?** |

### 1. 타이밍 — "세 개의 시계"가 동시에 돈다

Next.js `CacheLife` 타입이 이 복잡성을 정면으로 보여줍니다:

```ts
// ref/next.js/packages/next/src/server/use-cache/cache-life.ts:5-15
export type CacheLife = {
  stale?: number      // 클라이언트가 서버 확인 없이 쓸 수 있는 시간
  revalidate?: number // 서버가 백그라운드에서 갱신을 시작하는 시간
  expire?: number     // 트래픽이 없을 때 완전히 만료되는 시간
}
// Cache-Control: max-age=[stale], s-maxage=[revalidate],
//                stale-while-revalidate=[expire-revalidate]
```

이건 단일 시간이 아닙니다. **세 개의 독립적인 시계**가 동시에 돕니다:

```
시간 축 ──────────────────────────────────────────→

캐시 생성     stale 만료        revalidate 시작     expire 만료
    │            │                   │                  │
    ▼            ▼                   ▼                  ▼
────[  신선함  ]──[클라이언트 확인 필요]──[서버 백그라운드 갱신]──[완전 폐기]──→
    │            │                   │                  │
    │  이 구간:   │  이 구간:          │  이 구간:         │
    │  그냥 씀   │  서버에 물어봄      │  구판 주되 새로 굽기 │  다시 처음부터
```

그리고 이 세 시계 사이에 **반드시** `revalidate ≤ expire` 제약이 있습니다:

```ts
// ref/next.js/packages/next/src/server/use-cache/cache-life.ts:65-74
if (profile.revalidate !== undefined && profile.expire !== undefined) {
  if (profile.revalidate > profile.expire) {
    throw new Error(
      'the expire option must be greater than the revalidate option.'
    )
  }
}
```

이걸 어기면 "갱신 주기가 만료 시점보다 긴" 논리적 모순이 생깁니다. 비유로: "30분마다 책을 갱신해라" + "10분 후 폐기해라" → 갱신 기회가 한 번도 오기 전에 버려짐.

### 2. 판단 — "어떤 데이터에 어떤 시계를 걸 것인가"

타이밍 옵션이 있다는 것은, 개발자가 매번 **판단**해야 한다는 뜻입니다. Next.js가 미리 정의한 프로필이 이 판단의 스펙트럼을 보여줍니다:

```ts
// 'seconds' → stale: 짧음, revalidate: 짧음, expire: 짧음
// 'days'    → stale: 김,   revalidate: 김,   expire: 김
// 'max'     → stale: ∞,    revalidate: ∞,    expire: ∞
```

이 판단이 어려운 이유: **데이터의 성격**을 개발자가 정확히 알아야 합니다.

- 주식 가격 → `seconds` (1초 전 데이터도 위험)
- 블로그 글 → `days` (하루 지나도 괜찮음)
- 회사 로고 → `max` (거의 안 바뀜)

하지만 현실에서는 **"이 API 응답이 얼마나 자주 바뀌는가?"**라는 질문에 정확히 답하기 어렵습니다. 그래서 보수적으로 짧게 잡으면 캐시 효과가 없고, 길게 잡으면 stale 데이터 문제가 생깁니다.

### 3. 타이밍 × 판단의 교차점 — "동시 요청" 문제

`withPromiseCache`가 이 교차점의 가장 깔끔한 예시입니다:

```ts
// ref/next.js/packages/next/src/lib/with-promise-cache.ts:16-27
return (...values: T) => {
  const key = getKey ? getKey(...values) : values[0]
  let p = cache.get(key)
  if (!p) {
    p = fn(...values)
    p.catch(() => cache.remove(key)) // 실패하면 캐시에서 제거
    cache.set(key, p)                // Promise 자체를 캐시!
  }
  return p
}
```

여기서 캐시하는 것은 **결과값이 아니라 Promise(진행 중인 작업)**입니다. 타이밍 문제: 100명이 동시에 같은 데이터를 요청하면, 원본에 100번 갈 필요 없이 **첫 번째 요청의 Promise를 공유**합니다. 판단 문제: 하지만 그 Promise가 실패하면? → `.catch(() => cache.remove(key))`로 캐시를 지워서 다음 요청이 재시도하게 합니다.

이건 "Thundering Herd(몰려드는 무리)" 문제에 대한 판단입니다 — **캐시 미스 순간에 동시에 몰리는 요청**을 어떻게 처리할 것인가.

### 시각화: 타이밍과 판단의 교차 매트릭스

```
                         판단 (무엇을)
                  쉬움 ◄──────────► 어려움
               │
    짧음       │  ① 간단          ② 위험
    (seconds)  │  주식 시세         인증 토큰
               │  자주 갱신 OK      짧게 잡으면 UX↓
  타           │                   길게 잡으면 보안↓
  이 ──────────┼──────────────────────────────
  밍           │
  (얼마나)     │  ③ 낭비 가능       ④ 가장 어려움
    김         │  정적 자산          사용자별 피드
    (days~max) │  너무 길면 배포 후   stale 보여줄까?
               │  반영 안 됨         실시간 요청할까?
               │                   (SWR 판단 영역)
               ▼
```

**④번 영역**이 실무에서 가장 자주 고민하는 곳입니다. "사용자 피드를 10초 캐시할까, 60초 캐시할까?" — 이 숫자 하나에 서버 비용, 사용자 경험, 데이터 정합성이 모두 걸려 있습니다.

### 정리: 왜 "타이밍 + 판단"이 병목인가

추론: 캐시의 다른 요소(자료구조, 저장소, 퇴거 알고리즘)는 한 번 정하면 거의 바뀌지 않습니다. LRU 구현을 매일 바꾸지는 않죠. 하지만 **"이 데이터를 얼마나 오래 캐시할 것인가(타이밍)"**와 **"이 데이터를 캐시해도 되는가(판단)"**는 데이터마다, API마다, 비즈니스 요구마다 달라지고, 시간이 지나면서도 바뀝니다. 즉, **캐시의 메커니즘은 한번 구축하면 끝이지만, 정책은 끊임없이 결정해야 하는 것** — 이것이 캐시가 "개념은 쉬운데 실전에선 어려운" 근본 이유입니다.

---

## Q4. 그 고민들을 React와 Next.js는 어떻게 해결하려 노력했나요?

### 비유: 도서관의 "자동화 시스템" 도입

Q3에서 사서가 직접 판단하는 게 병목이었습니다. React와 Next.js의 접근은 **"사서의 판단을 줄이는 시스템을 도입하자"**입니다.

| 전략 | 도서관 비유 | 해결하는 문제 |
|------|-----------|-------------|
| **React `cache()`** | "손님이 나가면 책상 자동 비움" (요청 단위 수명) | 타이밍 판단 제거 |
| **React Cache ref-counting** | "아무도 안 읽으면 자동 회수" | 수명 관리 자동화 |
| **Next.js `cacheLife` 프로필** | "초/분/시/일/주" 라벨 선반 — 사서가 라벨만 고르면 됨 | 판단 단순화 |
| **Next.js `cacheTag`** | "의학서적" 태그 → 리콜 시 해당 태그만 회수 | 시간 의존 제거 |
| **Next.js `use cache`** | "이 영역은 캐시 대상" 표시만 하면, 시스템이 알아서 | 선언적 캐시 |
| **SWR 패턴** | "구판 먼저 주고, 새 판 도착하면 교체" | 속도 vs 신선도 절충 |

### 1. React의 전략 — "타이밍 판단을 아예 없앤다"

**(1-A) `cache()` — 요청 스코프로 수명을 고정**

```
// ref/react.dev/src/content/reference/react/cache.md:65
// "React will invalidate the cache for all memoized functions
//  for each server request."
```

React의 `cache()`는 **"언제 버릴까?"라는 질문 자체를 없앱니다**. 수명 = 해당 서버 요청이 끝날 때. 개발자가 TTL을 고민할 필요가 없습니다.

비유 매칭: 도서관에서 "손님이 자리에서 일어나면 책상을 자동으로 비운다" — 퇴관 시간이나 유효기간 스티커가 필요 없습니다.

**(1-B) Cache ref-counting — 참조가 0이면 자동 해제**

```js
// ref/react-fork/packages/react-reconciler/src/ReactFiberCacheComponent.js:82-88
export function createCache(): Cache {
  return {
    controller: new AbortControllerLocal(),
    data: new Map(),
    refCount: 0,  // ← 참조 카운팅
  };
}
```

```js
// ref/react-fork/packages/react-reconciler/src/ReactFiberCacheComponent.js:103-118
export function releaseCache(cache: Cache) {
  cache.refCount--;
  if (cache.refCount === 0) {
    scheduleCallback(NormalPriority, () => {
      cache.controller.abort();  // ← 0이 되면 AbortController로 정리
    });
  }
}
```

React의 Cache는 **Fiber 트리의 생명주기에 연결**됩니다. 컴포넌트가 언마운트되면 refCount가 줄고, 0이면 `AbortController.abort()`로 진행 중인 요청까지 정리합니다.

비유 매칭: 책에 "현재 읽는 사람 수" 카운터를 붙입니다. 아무도 안 읽으면 자동으로 서가에 되돌려보냅니다. 사서가 "이 책 아직 쓰이나?" 판단할 필요가 없습니다.

**(1-C) `cache()` 키 설계 — 인자 기반 자동 매칭**

Q1에서 본 `ReactCacheImpl.js`의 트리 구조가 여기서도 작동합니다:

```js
// ref/react-fork/packages/react/src/ReactCacheImpl.js:55
export function cache<A: Iterable<mixed>, T>(fn: (...A) => T): (...A) => T {
```

개발자는 **키를 직접 설계하지 않습니다**. 함수 인자가 곧 키입니다. "어떤 인자 조합이 같은 요청인가?"를 React가 자동으로 판단합니다.

### 2. Next.js의 전략 — "판단을 단순화하고, 도구를 준다"

React가 "판단을 제거"하는 방향이라면, Next.js는 **"판단을 피할 수 없는 경우를 위한 도구"**를 제공합니다.

**(2-A) `use cache` — 선언적 경계**

```tsx
// ref/next.js/docs/01-app/03-api-reference/01-directives/use-cache.mdx:48-69
// 파일/컴포넌트/함수 레벨에서 'use cache'만 선언하면 됨
export async function getData() {
  'use cache'
  const data = await fetch('/api/data')
  return data
}
```

개발자가 하는 것: **"이건 캐시해도 돼"**라고 표시만 합니다. 캐시 키 구성은 프레임워크가 알아서 합니다:

```
// 캐시 키 = Build ID + Function ID + 직렬화된 인자 + (dev: HMR 해시)
```

특히 **Build ID가 키에 포함**된다는 점이 중요합니다. 새 배포 = 새 Build ID → **모든 캐시 자동 무효화**. "배포 후 구 캐시가 남아있는" 문제를 구조적으로 해결합니다.

**(2-B) `cacheLife` 프로필 — 타이밍 판단의 추상화**

```ts
// ref/next.js/packages/next/src/server/use-cache/cache-life.ts:24-31
type CacheLifeProfiles =
  | 'default'
  | 'seconds'
  | 'minutes'
  | 'hours'
  | 'days'
  | 'weeks'
  | 'max'
```

**"stale: 120, revalidate: 3600, expire: 86400"** 같은 숫자 대신, **"minutes"나 "days"라고만 쓰면 됩니다**. Q3에서 본 "세 개의 시계를 동시에 설정하는" 부담을 이름 하나로 줄인 겁니다.

그리고 커스텀 프로필도 `next.config`에 한 번만 정의하면 타입 자동완성까지 제공됩니다:

```ts
// ref/next.js/packages/next/src/server/lib/router-utils/cache-life-type-utils.ts:71-136
// 프로필 이름 → JSDoc으로 stale/revalidate/expire 수치를 보여주는 타입을 자동 생성
```

비유 매칭: 사서가 매번 "이 책은 며칠 둘까..." 고민하는 대신, "신간(seconds)", "참고서(days)", "고전(max)" 선반에 꽂기만 하면 되도록 만든 것.

**(2-C) `cacheTag` + `revalidateTag` — 시간에서 이벤트로**

```tsx
// ref/next.js/docs/01-app/03-api-reference/04-functions/cacheTag.mdx:40-48
export async function getData() {
  'use cache'
  cacheTag('my-data')       // ← 태그 부착
  const data = await fetch('/api/data')
  return data
}

// ref/next.js/docs/01-app/03-api-reference/04-functions/cacheTag.mdx:69-72
export default async function submit() {
  await addPost()
  revalidateTag('my-data')  // ← 이벤트 발생 시 무효화
}
```

이것이 **가장 근본적인 패러다임 전환**입니다. Q3의 핵심 어려움이 "얼마나 오래?"라는 **시간 기반 판단**이었는데, `cacheTag`는 이를 **"무엇이 바뀌었나?"라는 이벤트 기반**으로 바꿉니다.

- 시간 기반: "60초마다 갱신해" → 59초에 데이터가 바뀌면? 1초간 stale.
- 이벤트 기반: "글이 작성되면 'posts' 태그 무효화" → 바뀐 순간 즉시 반영.

비유 매칭: "30분마다 서가를 확인해라" (TTL) → "본사에서 개정판 알림이 오면 그때 교체해라" (태그). **사서가 시계를 볼 필요가 없어집니다.**

**(2-D) 격리된 실행 컨텍스트 — "잘못된 판단"을 구조적으로 차단**

```ts
// ref/next.js/packages/next/src/server/use-cache/use-cache-wrapper.ts:158-161
// cache generation cannot read anything from the context we're currently executing
// which might include request specific things like cookies() inside a React.cache()

// ref/next.js/docs/01-app/03-api-reference/01-directives/use-cache.mdx:196
// "cannot directly access runtime APIs like cookies(), headers(), or searchParams"
```

Q2에서 본 "사용자 A의 쿠키가 캐시에 섞여 들어가는" 문제를 **문법 수준에서 금지**합니다. 잘못된 판단을 할 여지 자체를 없앤 것.

### 3. 두 접근의 관계 — 역할 분담

```
          "타이밍/판단" 문제의 스펙트럼

  판단 불필요 ◄───────────────────────────► 판단 필수
       │                                      │
       │  React의 영역           Next.js의 영역  │
       │                                      │
  ┌────┴────────────────┐  ┌──────────────────┴────┐
  │ cache()             │  │ use cache             │
  │ → 요청 끝나면 버림    │  │ → 선언만 하면 키 자동    │
  │                     │  │                       │
  │ useMemo             │  │ cacheLife('days')      │
  │ → deps 바뀌면 버림    │  │ → 프로필로 타이밍 단순화  │
  │                     │  │                       │
  │ ref-counting        │  │ cacheTag + revalidateTag│
  │ → 아무도 안 쓰면 버림  │  │ → 시간→이벤트 패러다임   │
  │                     │  │                       │
  │ 격리된 스코프         │  │ Build ID 자동 포함      │
  │ → 잘못된 공유 차단    │  │ → 배포 시 전체 무효화    │
  └─────────────────────┘  └───────────────────────┘

       "판단을 제거"              "판단을 도와줌"
```

### 시각화: 캐시 전략 진화도

```
전통적 캐시                    React / Next.js의 해법
─────────────                 ─────────────────────

① 개발자가 TTL 숫자를 직접 설정    →  cacheLife('minutes') 프로필
   (stale=120, revalidate=3600)      (이름 하나로 세 시계를 설정)

② 개발자가 캐시 키를 수동 구성     →  인자/props가 자동으로 키
   (hash(url + params + user))       (Build ID + Function ID + 인자)

③ 타이머 만료로 무효화            →  cacheTag + revalidateTag
   ("60초 후 버려")                   ("posts가 바뀌면 버려")

④ 캐시 범위를 코드로 관리         →  'use cache' 디렉티브
   (if/else + cache.get/set)          (선언만 하면 프레임워크가 처리)

⑤ stale 데이터 vs 속도 트레이드오프 →  SWR 패턴 내장
   (구판 줄까? 새 판 기다릴까?)        (구판 즉시 + 새 판 백그라운드)

⑥ 요청 맥락 오염 가능             →  실행 컨텍스트 격리
   (cookies가 캐시에 섞임)             (RequestStore 접근 차단)
```

### 정리

추론: React와 Next.js의 공통 철학은 **"개발자가 내려야 하는 판단의 수를 줄이자"**입니다.

- React는 **수명을 자동으로 결정**합니다 (요청 스코프, ref-counting, deps 비교). 타이밍 판단이 아예 필요 없는 곳을 담당합니다.
- Next.js는 **판단이 불가피한 곳에 더 좋은 도구**를 줍니다. 숫자 대신 프로필(`cacheLife`), 시간 대신 이벤트(`cacheTag`), 명령형 대신 선언형(`use cache`).

둘 다 "캐시를 완벽하게 해결"하지는 못합니다. 하지만 Q3에서 본 **④번 영역(긴 수명 + 어려운 판단)**을 가능한 한 **①번 영역(짧은 수명 + 쉬운 판단)**으로 끌어내리려 노력하고 있는 것입니다.

---

## 연결

| 대상 토픽 | 관계 | 근거 |
|-----------|------|------|
| `study/learn/React-리렌더링-비용과-메모이제이션.md` | 캐시의 구체적 적용 사례 (하위 메커니즘) | useMemo/React.memo는 캐시 3요소(Key=deps, Storage=Fiber, Invalidation=deps 변경)의 구체적 인스턴스. Q1의 보편적 패턴 테이블에서 React 행에 해당 |


---

## 2026-02-26 (via /learn)

## 세션 요약 (2026-02-26)

Q1~Q4, 4개 Q&A 진행.

- Q1: 캐시의 본질 — 3요소(Key/Storage/Invalidation), LRU 구현(Next.js lru-cache.ts), 보편적 패턴 테이블(CPU~DNS)
- Q2: 캐시가 어려운 이유 — 무효화(시간·태그 다대다), 숨겨진 상태(RequestStore 차단), 중첩 계층, 키 동등성(참조 vs 값)
- Q3: 핵심 병목 = 타이밍 × 판단 — CacheLife 세 시계(stale/revalidate/expire), 데이터 성격별 판단, Thundering Herd(Promise 캐시), 메커니즘 vs 정책 구분
- Q4: React/Next.js의 해법 — React(요청 스코프 cache, ref-counting, 인자 기반 키), Next.js(use cache 선언적, cacheLife 프로필, cacheTag 이벤트 기반, 실행 컨텍스트 격리, Build ID 자동 무효화)

비유: 도서관 체인(책상=캐시, 서가=원본) → 사서의 딜레마(타이밍/판단) → 자동화 시스템 도입(React/Next.js)
연결: React-리렌더링-비용과-메모이제이션 (캐시 3요소의 구체적 적용 사례)
