---
name: learn
description: 자유 Q&A 기반 학습 — 질문 → 근거 탐색(ref/웹/추론) → 답변 → 반복 → 문서화
argument-hint: "<질문>"
disable-model-invocation: true
allowed-tools: Read, Grep, Glob, WebSearch, WebFetch, Write, mcp__study__context_resolve, mcp__study__session_appendLog
---

입력: `$ARGUMENTS` (예: `Suspense는 어떠한 원리로 동작하나요?`)

실행 순서:

1. `context.resolve(mode=skill, skill=learn)`로 컨텍스트 확인
2. 사용자 질문(`$ARGUMENTS`)에서 주제명 추출 (간결한 kebab-case, 예: `Suspense-동작원리`)
3. 세션 복원/초기화

   상태 파일: `study/learn/session-state.md`

   3-A. Read 시도:
     - 파일 없음 또는 `# COMPLETED` → 새 세션 → Step 3-C
     - 활성 내용 + 당일 → "이전 세션 복원. Q{N}부터 계속합니다." → 상태 복원 → Step 4
     - 활성 내용 + 이전 날짜 → "이전 세션 발견 ({날짜}). 이어서/새로?" → 사용자 선택

   3-B. 복원 정보:
     - topic, qaCount, analogyFrame, connections, nextDirection, qaHistory

   3-C. 새 세션 → 상태 파일 초기화 Write:
     ```
     # SESSION-STATE
     updated: {YYYY-MM-DD HH:MM}
     topic: {주제명}
     qaCount: 0
     analogyFrame: (미결정)
     connections: (없음)
     nextDirection: 초기 탐색
     ---
     ## QA Summary
     (없음)
     ---
     ## QA History
     (없음)
     ```

4. 근거 탐색 — 아래 우선순위를 순서대로 시도한다.

   | 우선순위 | 소스 | 도구 | 조건 |
   |---------|------|------|------|
   | 1 | `ref/` 하위 소스코드 | Glob, Grep, Read | 관련 코드 존재 시 `file:line` 인용 |
   | 2 | 웹 검색 | WebSearch, WebFetch | ref/에서 충분한 근거를 못 찾은 경우 |
   | 3 | 추론 | — | 1+2 결과를 바탕으로 AI가 추론. 반드시 "추론:" 접두사 명시 |

   ref/ 폴백 규칙:
   - ref/ 탐색 결과가 없을 때: "ref/에 관련 소스 없음, 웹 검색으로 전환합니다" 사용자 알림 후 우선순위 2로 진행
   - 웹 소스 선호 순위:
     1. 공식 문서 (react.dev, nextjs.org 등)
     2. GitHub 소스 코드 (원본 저장소)
     3. 스펙/RFC (TC39, W3C, IETF 등)
     4. 핵심 기여자/공식 블로그
     5. 일반 기술 아티클
   - 버전 표기: 웹 소스 인용 시 버전 또는 날짜 병기 (예: "React 19 문서 (2024-12)")
   - 웹 코드 접두사: 웹에서 가져온 코드는 "외부 코드:" 접두사 (예: "외부 코드: (react.dev, v19)")

5. 아래 순서로 답변한다. (선행 조직자 → 상세 → 통합)
   - 5-A. **비유** — 핵심 개념마다 실생활 비유를 **먼저** 제시한다.
     - 목적: 세부 설명 전에 머릿속 프레임을 형성한다.
     - 1:1 대응 가능한 비유를 사용하고, 대응 관계를 명시한다.
     - 1:1 대응이 불가능하면 "비유 한계:" 접두사로 이유와 부분 비유를 제시한다.
     - 대응 요소가 3개 미만이면 비유를 생략하고 "비유 한계:" 설명만 남긴다.
   - 5-B. **코드/텍스트 설명** — 비유 프레임 위에 근거를 쌓는다.
     - ref/ 코드 근거: `file:line` 경로 포함
     - 웹 근거: 출처 URL + 버전/날짜 포함
     - 웹 소스 코드: "외부 코드:" 접두사 + 출처 (예: "외부 코드: (react.dev, v19)")
     - 추론: "추론:" 접두사로 명확히 구분
     - 설명 중 비유 요소와 실제 코드/개념의 매칭 이유를 서술한다.
       (예: "비유에서 X에 해당하는 것이 코드에서는 Y인데, 그 이유는 …")
   - 5-C. **시각화** — 최종 정리로 핵심을 시각화한다.
     - ASCII 다이어그램, 테이블, 플로차트, 상태전이도 중 적합한 것을 선택한다.
     - 비유 요소 ↔ 실제 개념 매핑을 시각화에 반영하면 더 좋다.
     - 생략 조건: 단일 사실 확인(예/아니오 수준)인 경우.
     - 거창할 필요 없다. 핵심 관계나 흐름만 보여준다.
   - 5-D. **연결** — 기존 학습 내용과의 연관을 탐색한다.
     - `study/` 디렉토리를 Glob/Grep/Read로 스캔한다.
     - 대화 중: 발견 시 간략히 언급한다.
     - 문서: `## 연결` 섹션에 구조적으로 기록한다.
     - 판단 기준: 동일 개념의 다른 관점, 상위/하위 메커니즘, 인과 관계, 전제 지식.
     - 억지 연결 금지 (단순 동일 라이브러리 수준은 연결하지 않는다).
6. 사용자의 추가 질문을 대기한다. → Step 4~5 반복.
   - 매 Q&A 후 `study/learn/session-state.md`를 Write 갱신한다 (qaCount++, analogyFrame, connections, nextDirection, QA Summary에 핵심 1줄 + refs 축적, QA History 추가).

종료(`>>정리`) 시:

1. 전체 Q&A를 `study/learn/<주제명>.md`에 Write한다.
   - 포맷: 아래 템플릿을 따른다.
   - 원문 그대로 기록한다. 오탈자만 수정.
2. `session.appendLog(context, topic=<주제명>, content=<요약>)`로 세션 기록.
3. `study/learn/session-state.md`를 `# COMPLETED\n` 마커로 Write한다.

문서 템플릿:

```markdown
# <주제명>

> 최초 질문: <사용자의 원본 질문>
> 일시: <YYYY-MM-DD>

---

## Q1. <사용자 질문>

<답변 원문>

## Q2. <사용자 후속 질문>

<답변 원문>

...

---

## 연결

| 대상 토픽 | 관계 | 근거 |
|-----------|------|------|
| `study/<skill>/<Topic>.md` | <관계 유형> | <왜 연결되는지 + 비유> |

연결이 없으면 이 섹션을 생략한다.
```

사용자 신호 규칙:
- `>>정리` — 세션 종료 + 문서화 실행
- 일반 대화 속 "정리"는 신호로 인식하지 않는다 (`>>` 접두사 필수).

규칙:
- ref/ 코드가 있으면 반드시 먼저 탐색한다. 웹 검색만으로 대체하지 않는다.
- ref/ 전환 알림 필수: ref/ 탐색 결과 없을 시 "ref/에 관련 소스 없음, 웹 검색으로 전환합니다" 알림 후 진행한다 (무언의 전환 금지).
- 근거의 출처(ref 코드/웹/추론)를 항상 명시한다.
- "외부 코드:" 접두사: 웹에서 가져온 코드 블록에는 반드시 "외부 코드:" 접두사 + 출처를 표기한다.
- 웹 소스 인용 시 버전 또는 날짜를 반드시 병기한다.
- 쓰기 동작은 `>>정리` 이후에만 수행한다. 예외: `session-state.md`는 매 Q&A 후 갱신한다.
- 답변 순서: 비유(프레임) → 코드/텍스트(근거+매칭) → 시각화(통합 정리). 이 순서를 지킨다.
- 비유는 1:1 대응을 기본으로 한다. 억지 비유보다 "비유 한계:" 설명이 낫다.
- 코드/텍스트 설명 시 비유 요소와의 매칭 이유를 반드시 서술한다.
- 시각화는 단일 사실 확인이 아닌 한 포함한다. 최종 정리 역할로, 비유↔실제 매핑을 반영한다.
- 연결 탐색은 `study/` 스캔으로 수행한다. 단순 동일 라이브러리 연결은 금지한다.
