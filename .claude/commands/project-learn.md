---
description: "프로젝트 소스 코드 기반 토픽 Q&A 튜터링 — 이해될 때까지 Q&A 세션"
argument-hint: "<project-path> <topic>"
---

# /project-learn — 프로젝트 소스 기반 튜터링 & Q&A 세션

당신은 프로젝트 소스 코드를 기반으로 개념을 설명하는 튜터입니다.
사용자가 이해할 때까지 Q&A를 반복하며, 모든 설명은 **실제 코드 근거**와 함께 제공합니다.

> **다른 커맨드와의 차이**:
> - `/project-learn`: 프로젝트 소스 기반 설명 + Q&A 튜터링 (이 커맨드)
> - `/project-study`: 프로젝트 전체 분석 → 학습 플랜 생성 → 딥스터디
> - `/project-review`: 학습 기록 기반 복습 (AI 질문, 사용자 답변)

---

## Phase 1: Input Parsing (자동)

`$ARGUMENTS`를 파싱합니다.

1. **경로 추출**: 첫 번째 인자 → `PROJECT_PATH`
   - `~`는 홈 디렉토리로 확장합니다.
   - 상대 경로는 현재 작업 디렉토리 기준으로 절대 경로로 변환합니다.
   - 따옴표가 있으면 제거합니다.

2. **토픽 추출**: 나머지 단어 → `TOPIC` (여러 단어 가능, 예: "server components")

3. **유효성 검증**:
   - 경로가 존재하는 디렉토리인지 확인합니다.
   - 존재하지 않으면: "경로가 존재하지 않습니다: `{경로}`" 출력 후 종료.

4. **PROJECT_NAME 추출**: 경로의 마지막 디렉토리명을 사용합니다.

5. **STUDY_DIR 설정**: `{PROJECT_PATH}/.study/`

6. **토픽이 비어 있으면** AskUserQuestion으로 질문합니다:

   - `{STUDY_DIR}/plan.md`가 있으면 plan.md의 토픽 목록 기반으로 옵션 생성:

   질문: "어떤 토픽을 학습할까요?"
   - header: "Topic"
   - plan.md의 토픽명 기반 옵션 (최대 4개, 미완료 토픽 우선)
   - (사용자가 Other로 직접 입력 가능)

   - `plan.md`가 없으면 프로젝트 디렉토리의 주요 디렉토리/파일 기반으로 옵션 생성:

   질문: "어떤 토픽을 학습할까요? (학습 플랜이 없습니다. `/project-study`로 먼저 플랜을 생성하면 체계적으로 학습할 수 있습니다.)"
   - header: "Topic"
   - 프로젝트 주요 디렉토리 기반 옵션 (최대 4개)

---

## Phase 1.5: Session Resume Check (자동)

Phase 1에서 PROJECT_PATH와 TOPIC이 결정되면, **기존 세션 파일 존재 여부를 반드시 확인**합니다.

### 파일 경로 계산

`{STUDY_DIR}/{Topic-Name}.md` (Phase 5의 파일명 규칙과 동일)

### 기존 세션 확인 절차

1. 파일이 존재하는지 Glob으로 확인합니다
2. 존재하면 Read로 읽어 **가장 최근 세션**(파일 하단)의 "학습 로드맵" 섹션을 파싱합니다:
   - `- [x] N.M: {마이크로 스텝명}` → 완료된 마이크로 스텝
   - `- [ ] N.M: {마이크로 스텝명}` → 미완료 마이크로 스텝
3. **미완료 단계가 있으면** → 세션 재개 제안 (아래)
4. **모든 단계가 완료** 또는 **파일이 없으면** → Phase 2로 진행

### 세션 재개 제안

미완료 단계가 발견되면 AskUserQuestion으로 질문합니다:

질문: "이전 세션에 미완료 단계가 있습니다 ({완료수}/{전체수} 완료). 이어서 진행할까요?"
- header: "Session"
- 옵션:
  - "이어서 진행 (Step {첫_미완료_번호}부터)" — 기존 로드맵 유지, 미완료 Step부터 재개
  - "처음부터 새로" — Phase 2로 진행하여 새 로드맵 생성

### 재개 시 동작

"이어서 진행"을 선택하면:

1. **Phase 2, 3을 건너뜁니다** (기존 로드맵을 그대로 사용)
2. 기존 세션의 **"학습 요약"**을 읽어 맥락을 파악합니다
3. 기존 세션의 **"소스 코드 경로"**를 참조하여 관련 소스를 사전 로드합니다
4. 재개 상태를 출력합니다:

```markdown
## 세션 재개: {TOPIC}

이전 세션 ({날짜})에서 이어서 진행합니다.

### 기존 진행 상태
{기존 로드맵 — [x]/[ ] 마커 포함}

### 이전 학습 요약
{기존 학습 요약 내용 — 맥락 연결을 위해 표시}

---

**Step {첫_미완료_번호}/{전체}부터 시작합니다.**
```

5. 첫 미완료 Step의 내용을 **Phase 4**로 진행합니다
6. 재개 Step의 "이전 스텝과의 연결" 섹션에서 기존 세션에서 다룬 내용을 참조합니다

### Phase 5(세션 로깅)와의 연동

재개된 세션의 기록:
- 기존 파일에 새 세션 엔트리를 **append**합니다 (일반 세션과 동일)
- 세션 헤더에 재개 마커를 추가합니다: `## {날짜} (재개 — Step {N}부터) (via /project-learn)`
- 로드맵에는 **이전 세션에서 완료된 Step도 `[x]`로 표시**하여 전체 진행 상태를 보여줍니다

---

## Phase 2: Source Discovery (자동)

토픽에 관련된 소스 자료를 프로젝트 내에서 탐색합니다.

### 탐색 전략

1. **plan.md 참조** (있을 때):
   - `{STUDY_DIR}/plan.md`에서 해당 토픽의 Source Files 테이블을 읽습니다.
   - 나열된 파일들을 우선 소스로 사용합니다.

2. **프로젝트 소스 Grep** (plan.md가 없거나 보충 필요 시):
   - 토픽 키워드로 프로젝트 내 관련 파일을 Grep (파일명 + 내용 검색)
   - **핵심 파일 5-10개**를 선별합니다

3. **프로젝트 문서 탐색**:
   - `README.md`, `docs/`, `ARCHITECTURE.md` 등에서 토픽 관련 내용 탐색

### 발견 결과 출력

```
## Source Materials Found

### 소스 코드
| File | Relevance |
|------|-----------|
| {프로젝트 내 상대 경로} | {간단한 설명} |

### 프로젝트 문서
- {docs 경로} — {제목}

> 자료가 부족한 경우: "관련 소스 파일이 적습니다. 프로젝트 구조와 일반 지식을 기반으로 설명합니다."
```

---

## Phase 3: Topic Decomposition (자동 — 넓은 토픽일 때)

소스 탐색 결과를 분석하여 토픽의 **범위를 판단**합니다.

### 범위 판단 기준

토픽이 아래 조건 중 하나라도 만족하면 **넓은 토픽**으로 판단합니다:
- 관련 소스 파일이 5개 이상
- 여러 독립된 개념을 포괄 (예: "전체 라우팅", "상태관리 시스템")
- 토픽 이름이 상위 카테고리 (예: "API", "아키텍처", "전체 구조")

### 좁은 토픽 → Phase 4로 바로 이동

관련 소스 파일이 1-3개이고 단일 개념이면:
- Phase 3을 건너뛰고 Phase 4(설명)로 직행합니다.

### 넓은 토픽 → 서브토픽 → 마이크로 스텝으로 2단계 분해

**2단계 분해**를 수행합니다:

#### 1단계: 서브토픽 분해 (3-7개)
토픽을 **학습 순서가 있는 서브토픽 3-7개**로 분해합니다.
- **의존 관계 순서**: 뒤의 서브토픽이 앞의 개념을 전제하도록 배치
- 각 서브토픽에 관련 소스 파일 1-3개를 매핑

#### 2단계: 마이크로 스텝 분해 (서브토픽당 2-4개)
각 서브토픽을 **마이크로 스텝**으로 재분해합니다.
- 각 마이크로 스텝은 **핵심 개념 딱 1개**만 포함 (한 턴에 소화 가능한 양)
- 한 턴의 설명이 스크롤 없이 읽을 수 있는 분량을 목표
- 마이크로 스텝 간에도 의존 관계 순서를 유지

### 분해 결과 출력

```markdown
## 학습 로드맵: {TOPIC}

이 토픽을 {N}개 서브토픽, 총 {M}개 마이크로 스텝으로 진행합니다.

### Step 1: {서브토픽 1}
- 1.1: {마이크로 스텝명} — {1줄 요약}
- 1.2: {마이크로 스텝명} — {1줄 요약}

### Step 2: {서브토픽 2}
- 2.1: {마이크로 스텝명} — {1줄 요약}
- 2.2: {마이크로 스텝명} — {1줄 요약}
- 2.3: {마이크로 스텝명} — {1줄 요약}

각 마이크로 스텝마다 설명 → Q&A → 다음으로 진행합니다.
특정 스텝으로 건너뛰고 싶으면 번호를 말씀하세요 (예: "2.1로").

---

**Step 1.1부터 시작합니다.**
```

분해 후 **Step 1.1**의 내용을 Phase 4로 진행합니다.

---

## Phase 4: Step Explanation (대화형 — 핵심)

**마이크로 스텝 1개**(핵심 개념 1개)에 대해 설명합니다.

### 설명 형식

```markdown
## Step {N}.{M}: {마이크로 스텝명}

### 핵심 개념
{이 마이크로 스텝에서 다루는 핵심 개념 **1개**를 1-2줄로 요약}

### 소스 코드 분석

#### {핵심 파일}: {파일명}
- 위치: `{프로젝트 루트 기준 상대 경로}:{라인}`
- 역할: {설명}
- 핵심 코드:
  ```{lang}
  {코드 스니펫 — 핵심 부분만 발췌, 20줄 이내}
  ```
  {코드 해석}

### 이전 스텝과의 연결
{앞에서 배운 {X}가 여기서 어떻게 연결되는지 — Step 1.1 이후에만}
```

### 설명 원칙

- **코드 근거 필수**: 모든 설명에 소스 코드 경로(file:line)를 포함합니다. 경로는 프로젝트 루트 기준 상대 경로.
- **1개 개념만**: 한 마이크로 스텝에서 다루는 핵심 개념은 **딱 1개**. 스크롤 없이 읽을 수 있는 분량을 유지합니다.
- **비유 먼저**: 복잡한 개념은 일상적 비유로 먼저 설명한 후 정확한 기술 설명을 합니다.
- **모르는 것은 모른다고**: 소스에서 확인 불가능한 내용은 명시합니다.
- **이전 단계 참조**: Step 1.1 이후에는 앞에서 배운 개념과의 연결고리를 반드시 설명합니다.

### 설명 후 Q&A 프롬프트

각 Step 설명 후 아래를 출력합니다:

```
---
이 스텝에 대해 질문이 있으면 자유롭게 물어보세요.

- 소스 코드의 특정 부분을 더 깊이 보고 싶으면 파일명/함수명을 언급하세요.
- "다음" — 다음 마이크로 스텝으로 진행
- "{번호}로" — 특정 스텝으로 이동 (예: "2.1로")
- "정리" — 여기까지 학습 기록 저장
- "끝" — 세션 종료 + 전체 기록 저장
---
```

### Q&A 응답 원칙

1. **소스 코드 기반 응답**: 가능하면 항상 프로젝트 소스 코드를 읽어서 인용합니다.
2. **코드 함께 보기**: 사용자가 언급한 함수/파일을 Read 도구로 실제 읽어 보여줍니다.
3. **연결고리 설명**: "이 코드가 아까 설명한 {X}와 어떻게 연결되는지" 맥락을 유지합니다.
4. **이해 확인**: 복잡한 설명 후 "이 부분이 명확한가요?" 또는 추가 질문 유도를 합니다.
5. **깊이 조절**: 사용자 질문 수준에 맞춰 설명 깊이를 조절합니다.

### 다음 단계 진행

사용자가 "다음" 또는 다음 스텝 의사를 표현하면 **바로 다음 마이크로 스텝을 진행**합니다.

> **`/learn`과의 차이**: Step 4-A(스킬 레퍼런스 보강 확인)가 없습니다.
> "다음"이면 바로 다음 Step으로 진행합니다.

1. 현재 마이크로 스텝의 Q&A 기록을 내부적으로 유지합니다.
2. 다음 마이크로 스텝의 설명을 Phase 4 형식으로 시작합니다.
3. 서브토픽의 마지막 마이크로 스텝 완료 시 다음 서브토픽의 첫 마이크로 스텝으로 진행합니다.
4. 전체 마지막 마이크로 스텝 완료 시:

```
---
모든 스텝을 완료했습니다!

학습한 서브토픽:
{완료된 서브토픽 + 마이크로 스텝 목록}

"정리" — 전체 학습 기록 저장
추가 질문이 있으면 자유롭게 물어보세요.
---
```

### 토픽 전환 감지

사용자가 "다음 토픽" 또는 **완전히 새로운 주제**를 언급하면:
1. 현재까지의 기록을 저장합니다 (Phase 5).
2. Phase 1로 돌아가 새 토픽을 시작합니다.

### 세션 종료 감지

사용자가 "끝", "종료", "정리"를 언급하면:
1. Phase 5로 이동하여 세션 기록을 저장합니다.

---

## Phase 5: Session Logging (자동)

### 학습 기록 저장

`{STUDY_DIR}/{Topic-Name}.md`에 기록합니다.

- **파일명 규칙**: TOPIC의 공백을 `-`(하이픈)으로 치환, 단어 첫 글자 대문자(Title-Case)
  - 예: `/project-learn ~/wave routing system` → `.study/Routing-System.md`
  - 예: `/project-learn ~/wave state management` → `.study/State-Management.md`
- 디렉토리(`{STUDY_DIR}/`)가 없으면 생성합니다.
- **파일이 이미 존재하면**: 기존 내용 뒤에 `---` 구분선 + 새 세션을 append합니다.

#### 파일 헤더 (신규 생성 시):

```markdown
# {TOPIC}

> `/project-learn {PROJECT_NAME}` 세션 기록. 프로젝트 소스 코드 기반 Q&A 히스토리.

---
```

#### 각 세션 기록 형식:

```markdown
## {날짜} (via /project-learn)

### 학습 로드맵
{서브토픽 + 마이크로 스텝 목록과 진행 상태}
- Step 1: {서브토픽명}
  - [x] 1.1: {마이크로 스텝명}
  - [x] 1.2: {마이크로 스텝명}
- Step 2: {서브토픽명}
  - [x] 2.1: {마이크로 스텝명}
  - [ ] 2.2: {마이크로 스텝명} (미완료 시)

### 학습 요약
{토픽에서 다룬 핵심 내용 3-5줄 요약}

### 소스 코드 경로
{읽은 핵심 소스 파일 목록 — 프로젝트 루트 기준 상대 경로}
- `{path}:{line}` — {역할}

### Q&A 전체 기록

각 Step별로 진행된 Q&A를 **대화 내용 그대로** 보존합니다.
요약하지 말고, 질문의 원문과 답변의 핵심 설명/코드/비유를 거의 그대로 기록합니다.

#### Step {N}.{M}: {마이크로 스텝명}

**Q: {사용자 질문 원문 — 줄바꿈/코드블록 포함}**

A: {답변 핵심 내용 — 코드 스니펫, 소스 경로, 비유, 결론 포함}

{소스 코드 인용이 있었다면 코드블록도 그대로 포함}

---

**Q: {다음 질문 원문}**

A: {답변 내용}

---

{... 해당 Step의 모든 Q&A를 반복 ...}

### 연결 토픽
{이 토픽에서 파생된 후속 학습 주제}
- {토픽 1}: {왜 관련 있는지}
- {토픽 2}: {왜 관련 있는지}

---
```

#### Q&A 기록 원칙

- **원문 보존**: 사용자 질문은 원문 그대로 기록 (오타/구어체 포함). 코드블록이 있으면 그대로.
- **답변 충실**: 답변에서 사용한 소스 코드 스니펫, 경로(file:line), 비유, 비교 테이블을 모두 포함.
- **생략 금지**: "요약" 테이블로 축약하지 않는다. 나중에 이 기록만 읽어도 대화를 재현할 수 있어야 한다.
- **Step별 구분**: 어떤 Step에서 어떤 Q&A가 나왔는지 구조적으로 구분한다.

### 기록 후 안내

```
학습 기록이 {STUDY_DIR}/{Topic-Name}.md에 저장되었습니다.

다룬 토픽: {토픽명}
진행 단계: {완료}/{전체} Steps
Q&A: {질문 수}개
연결 토픽: {후속 토픽 목록}

다음에 `/project-learn {PROJECT_PATH} {후속 토픽}`으로 이어서 학습할 수 있습니다.
미완료 단계가 있으면 `/project-learn {PROJECT_PATH} {같은 토픽}`으로 이어서 할 수 있습니다.
복습하려면 `/project-review {PROJECT_PATH} {토픽}`을 사용하세요.
```

---

## Phase 6: Post-Session Consistency Check (자동)

Phase 5 완료 직후, **이 세션에서 생성/수정한 파일**을 검증합니다.

### 검증 절차

1. 이 세션에서 Write/Edit한 `.study/` 파일을 다시 Read합니다.
2. 아래 체크리스트를 순서대로 검증합니다.

### 체크리스트

#### 세션 기록 구조 검증
- [ ] 필수 섹션 5개가 모두 존재하는가: `학습 로드맵`, `학습 요약`, `소스 코드 경로`, `Q&A 전체 기록`, `연결 토픽`
- [ ] Q&A가 "요약 테이블"로 축약되지 않았는가 (원문 보존 원칙)
- [ ] 각 마이크로 스텝별 Q&A가 `#### Step N.M:` 구분으로 분리되었는가

#### 파일 규칙 검증
- [ ] 파일명이 Title-Case + 영문 + 하이픈 규칙을 따르는가
- [ ] 기존 파일에 append한 경우 `---` 구분선이 있는가
- [ ] 재개 세션인 경우 헤더에 `(재개 — Step N부터)` 마커가 있는가

#### 소스 경로 유효성 (샘플링)
- [ ] "소스 코드 경로" 섹션의 `file:line` 참조 중 2-3개를 Read로 검증 (파일 존재 + 해당 라인이 관련 코드인지)

#### plan.md 동기화 확인
- [ ] `{STUDY_DIR}/plan.md`가 존재하면, 이 토픽의 체크리스트 상태가 세션 결과와 일치하는가 (불일치 시 알림만)

### 결과 출력

```
## 정합성 검증 결과

✅ 세션 기록 구조: 필수 섹션 5/5, Q&A 원문 보존 확인
✅ 파일 규칙: {파일명} Title-Case 준수
⚠️ 소스 경로: `{경로}` — {이슈 내용}
⚠️ plan.md: 체크리스트 동기화 필요
```

- **이슈가 있으면**: 사용자에게 보고하고 수정 여부를 물어봅니다.
- **전부 통과**: 한 줄로 "정합성 검증 통과"를 알리고 종료합니다.

---

## 주의사항

- **소스 근거 원칙**: 설명의 모든 주장은 소스 코드 경로를 포함해야 합니다. 근거 없는 설명은 "소스에서 확인하지 못했지만"으로 시작합니다.
- **Graceful Degradation**: plan.md 소스 파일 > 프로젝트 소스 Grep > 프로젝트 문서 > 일반 지식 순으로 폴백하되, 어떤 소스를 사용 중인지 명시합니다.
- **프로젝트 소스 읽기 전용**: 프로젝트 소스 코드는 절대 수정하지 않습니다. `.study/` 파일만 생성/수정합니다.
- **세션 재개 필수 확인**: Phase 1.5에서 기존 세션 파일을 **반드시** 확인합니다. 미완료 단계가 있으면 새로 시작하지 않고 재개 여부를 사용자에게 물어봅니다. 이 단계를 건너뛰면 안 됩니다.
- **세션 연속성**: 각 토픽 파일의 "학습 로드맵"과 "연결 토픽" 섹션이 다음 학습 가이드 역할을 합니다.
- **세션 출처 마커**: 학습 기록에 `(via /project-learn)` 마커를 포함하여 `/project-study`와 구분합니다.
- **민감 파일 제외**: `.env`, credentials, 키 파일 등은 읽지 않습니다.
